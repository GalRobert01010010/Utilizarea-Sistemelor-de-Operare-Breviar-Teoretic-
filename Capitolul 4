# Capitolul 4: Procese

Def. Proces = aplicatie care se executa in sistemul de operare, folosind resursele sistemului, pentru a realiza o actiune ceruta de user.
- la nivelul sistemului de operare, aceste aplicatii sau comenzi pornite de user sunt procese
- procesele ruleaza, se executa, sau se afla in executie
- procesele cunt entitati active, care atunci cand ruleaza, folosesc resursele sistemului: procesor, memorie, sistem de fisiere
Def. Procese interactive = procese pornite prin actiunea unui utilizator, precum rularea unei aplicatii grafice sau a unei comenzi.
  - acestea interactioneaza cu utilizatorul pe parcursul rularii lor
Def. Procese neinteractive = procese pornite de catre sistem, care nu interactioneaza cu utilizatorul.
  - au rol in gestiunea sistemului sau oferirea de servicii (Ex. actualizarea ceasului, indexarea fisierelor pentru cautare rapida etc.)
  - se mai numesc servicii sau procese daemon

- cand folosim interfata grafica, o fereastra de aplicatie care ruleaza poate avea in spate mai multe procese
Obs. Este esential ca orice aplicatie care ruleaza in sistem sa foloseasca unul sau mei multe procese pentru 
     a satisface cerintele utilizatorului.

Sistemul de operare ofera:
- izolare a resurselor proceselor, asigurandu-se ca un proces nu poate accesa sau corupe resursele altui proces
  - sistemul este mentinut integru 
- arbitrare a accesului la resursele partajate: daca doua sau mai multe procese acceseaza o resursa comuna, 
  un proces nu trebuie sa suprascrie informatiile altuia
- mecanisme explicite de comunicare intre procese
  - Ex. semnalele si pipe-urile sunt mecanisme de comunicare intre procese
- comportament echitabil al proceselor, pentru a ne asigura ca un proces nu foloseste prea multe resurse 
  - OS are grija sa aloce fiecarui proces resurse in mod echitabil

## 4.1: Programe si procese

- un proces ruleaza si foloseste resursele sistemului pentru a indeplini o anumita sarcina
  - pentru asta, foloseste resursele sistemului
- procesul stocheaza in memorie instructiunile pe care trebuie sa le execute

Se pune problema: Cum ajung aceste instructiuni in memorie?
  - nu vorbin de memoria fizica (HDD/SDD, aici locuieste programul), ci despre memoria activa (RAM)
  - un proces primeste instructiunile in momentul crearii sale
  - un proces e creat dintr-un program
  - programul e un fisier executabil care contine codul (instructiunile)
  - cand pornim o aplicatie sau rulam o comanda, un program este loaded
    - atunci are loc coperea instructiunilor din fisierul executabil in memoria viitorului proces si pornirea sa

- Utilitarul ps (Process Status)
  - Ne permite să vizualizăm starea proceselor active în sistem la un moment dat.

  Steaguri ps:

- -e (every)
  - Selectează toate procesele din sistem.
  - Comandă terminal: ps -e
  - Exemplu: ps -e

- --no-header
  - Elimină linia de antet din afișare pentru a lăsa doar datele brute.
  - Comandă terminal: ps [alte_steaguri] --no-header
  - Exemplu: ps -e --no-header

- -f (full-format)
  - Afișează detalii complete (UID, PID, PPID, C, STIME, TTY, TIME, CMD).
  - Comandă terminal: ps -f [alte_steaguri]
  - Exemplu: ps -ef

- -u (user / effective user)
  - Filtrează procesele după identitatea sub care rulează efectiv procesul acum.
  - Comandă terminal: ps -u [nume_utilizator_sau_UID]
  - Exemplu: ps -u student

- -U (real user)
  - Selectează procesele după utilizatorul real care a pornit inițial comanda.
  - Comandă terminal: ps -U [nume_utilizator_sau_UID]
  - Exemplu: ps -U root

- -G (real group)
  - Selectează procesele după grupul real din care face parte cel care a pornit procesul.
  - Comandă terminal: ps -G [nume_grup_sau_GID]
  - Exemplu: ps -G sudo

- -N (negate)
  - Afișează toate procesele, exceptând cele care se potrivesc filtrului setat.
  - Comandă terminal: ps -N [filtru_de_negat]
  - Exemplu: ps -N -u student

- -C (command)
  - Selectează procesele după numele exact al fișierului executabil.
  - Comandă terminal: ps -C [nume_executabil]
  - Exemplu: ps -C VBoxClient

- -o (output format)
  - Permite alegerea și ordonarea coloanelor afișate.
  - Comandă terminal: ps -o [coloana1,coloana2,...]
  - Exemplu: ps -e -o pid,cmd,%cpu,rss

- pid= (custom header)
  - Dezactivează antetul pentru coloana PID (folosit pentru a extrage doar numărul).
  - Comandă terminal: ps -o pid= [alte_filtre]
  - Exemplu: ps -o pid= -C VBoxClient

- --sort
  - Ordonează lista după o coloană specifică (folosește "-" pentru descrescător).
  - Comandă terminal: ps [filtre] --sort [+/-coloană]
  - Exemplu: ps -u student -o pid,cmd,%cpu --sort -%cpu

- aux (BSD style)
  - Format combinat: toate procesele (a), orientat pe utilizator (u), inclusiv cele fără terminal (x).
  - Comandă terminal: ps aux
  - Exemplu: ps aux

- --forest
  - Afișează vizual relația părinte-copil prin indentare grafică.
  - Comandă terminal: ps [filtre] --forest
  - Exemplu: ps -ef --forest

- -p (pid)
  - Afișează date doar pentru un anumit proces identificat prin număr.
  - Comandă terminal: ps -p [PID]
  - Exemplu: ps -p 1234

- -L (threads)
  - Afișează firele de execuție (LWP) din cadrul proceselor.
  - Comandă terminal: ps -L [alte_steaguri]
  - Exemplu: ps -efL

Obs. Diferența dintre -u și -U:
  - -u (effective user): Se uită la utilizatorul sub a cărui identitate rulează 
     procesul în prezent (poate fi schimbată prin mecanisme de tip SUID).
  - -U (real user): Se uită la utilizatorul care a pornit inițial procesul.
  - Comandă terminal: ps -U student -u root
  - Explicație: Această comandă ar găsi procesele pornite de "student" 
    care au primit drepturi de "root" (de exemplu, prin `sudo`).

Comparație și Exemple:
- Cum aflam ce proces consuma cel mai mult RAM sau CPU
  -> Folosind ps aux (coloanele %CPU și %MEM).
- Cum vedem ierarhia parinte-copil a proceselor
  -> Folosind ps -ef --forest sau ps -ejH.
- Cum aflam calea catre executabilul care a pornit procesul
  -> Analizand coloana CMD (ultima coloană) din ps -ef 
  -> Arată calea completă și argumentele (ex: /usr/lib/firefox/firefox).

Obs. Coloana PID (Process ID) este unică pentru fiecare proces. 
Obs. Coloana PPID (Parent Process ID) indică cine a creat acel proces (părintele).
Obs. PID 1 este întotdeauna procesul init (sau systemd), primul proces pornit de Kernel la boot-are.
     Este părintele tuturor celorlalte procese.
Obs. ps este aproape mereu combinat cu grep pentru a filtra rezultatele: ps -ef | grep firefox.
Obs. Diferența între ps -ef și ps aux: Prima folosește sintaxa standard UNIX (cu liniuță), a doua folosește sintaxa BSD (fără liniuță). 
     ps aux este preferat de administratori pentru că arată consumul de resurse (%CPU, %MEM).
Obs. Litera S în coloana STAT, indica faptul că procesul este în starea Sleeping (așteaptă un eveniment).
Obs. Spre deosebire de `top` sau `htop`, utilitarul `ps` nu se actualizeaza in timp real.

Esenta:
  - un program este o entitate statica, un fisier executabil in sistemul de fisiere
  - un proces este o entitate dinamica, una care ruleaza si foloseste resursele sistemului
    - pt un proces, spunem ca programul executabil din care a fost creat este imaginea procesului

## 4.2: Resursele si atributele unui proces

- instructiunile copiate in proces din fisierul executabil sunt executate de procesor
- pe parcursul executiei, un proces comunica cu elemente I/O si cu alte procese
- unui proces i se aloca memorie la creare si rulare
  - prin alocare dinamica (Ex. malloc())
- comenzi precum `ps` si `top` ne permit sa investigam si sa monitorizam resursele folosite de procese
- CPU (procesorul) este unitatea centrală care conține două componente majore: UAL și UC.
  - UAL (Unitatea Aritmetica si Logica): componenta care prelucreaza date brute primite de procesor
  - UC (Unitatea de Control): gestioneaza fluxul de date si sincronizarea intre componente

## 4.2.1: Atributele unui proces

- un proces are atribute primite implicit la pornirea sa: 
  -> identificatorul procesului, procesul părinte, utilizatorul, prioritatea de rulare
Def. Atributele = date despre un proces cu rolul de a identifica un proces, de a stabili ce 
     si cat de multe resurse poate folosi si de a contabiliza resursele utilizate.

Atributul PID:
  - id-ul unic al procesului la nivelul sistemului de operare
  - este primit in momentul crearii si nu se schimba pe parcursul rularii
  - comenzile ca re se refera la un proces primesc id-ul sau
  - pt a termina un proces folosim comanda `kill` urmata de PID-ul sau 

Atributul UID:
  - id-ul utilizatorului care detine procesul
  - procesul va avea acces la resursele utilizatorului care l-a pornit 

## 4.2.2: Utilitare pentru urmarirea pproceselor

Tipuri de utilitare:
  - care afiseaza un snapshot al momentului (procese active in acel moment si atributele lor)
  - care monitorizeaza procesele sistemului

PID
  - identifica procesul
  - e atribuit la pornire
  - nu e modificabil

PPID
  - identifica parintele proces
  - e atribuit la pornire
  - e modificabil
    - un proces nu își poate alege un alt părinte "la dorință", dar PPID-ul 
      se schimbă automat dacă părintele inițial moare (se termină) înaintea copilului.
    - Procesul de re-parenting: Când părintele moare, procesul copil devine orfan. 
      Pentru a nu rămâne suspendat, acesta este adoptat imediat de procesul cu PID 1 (systemd sau init).
    - Cum se face: Nu există o comandă terminal directă pentru a schimba părintele unui proces activ. 
      Schimbarea are loc doar prin terminarea procesului părinte actual.

Program executabil
  - constituie imaginea procesului (cod si date)
  - e atribuit la pornire
  - nu e modificabil

UID / GID
  - stabilesc permisiunile procesului
  - e atribuit la pornire
  - nu e modificabil (cu exceptia unor situatii punctuale)
    Situatiile punctuale:
      1. Executabile cu bitul SUID/SGID activ: 
         Dacă fișierul are bitul SUID (ex: /usr/bin/passwd), în momentul rulării, UID-ul procesului se 
         schimbă din "student" în "root" pentru a avea permisiunile necesare.
      2. Utilizarea sudo: 
         Comanda sudo permite lansarea unui proces direct cu UID 0 (root).
      3. Apeluri de sistem (setuid): 
         Un proces care rulează ca root poate decide singur să renunțe la privilegii și să își 
         schimbe UID-ul într-unul de utilizator obișnuit (pentru securitate).

Prioritate statică (nice)
  - indică importanța în accesul resurselor
  - e atribuită la pornire
  - este modificabilă

Terminal
  - reprezintă interfața de comunicare cu utilizatorul
  - e atribuit la pornire
  - e modificabil

Fișiere deschise
  - necesare pentru lucrul cu fișierele
  - sunt atribuite la rulare
  - sunt modificabile

Stare
  - indică accesul curent la procesor
  - e atribuită la rulare
  - e modificabilă

Timp de rulare pe procesor
  - util pentru contabilizarea consumului de procesor
  - e atribuit la rulare
  - e modificabil

Memorie consumată
  - utilă pentru contabilizarea consumului de memorie
  - e atribuită la rulare
  - e modificabilă

Spațiu virtual de adrese
  - constituie harta memoriei unui proces
  - e atribuit la pornire
  - e modificabil

1. Utilitare care afiseaza un snapshot al momentului

- ps (Process Status)   (randul 41 pt mai multe detalii)
  - Folosință: Afișează informații despre procesele active la un moment dat.
  - -e (afișează toate procesele)
    - Comandă terminal: ps -e
  - -f (afișează formatul complet de coloane)
    - Comandă terminal: ps -ef
  - -u (afișează procesele unui utilizator specific)
    - Comandă terminal: ps -u student
  - -p (afișează informații despre un PID anume)
    - Comandă terminal: ps -fp 1234
  - -o (afișează doar coloanele alese de tine)
    - Comandă terminal: ps -e -o pid,ppid,comm

- pgrep (Process Grep)
  - Folosință: Afiseaza procese care corespund unei anumite conditii.
  - -l (afișează și numele procesului, nu doar PID-ul)
    - Comandă terminal: pgrep -l ssh
  - -u (filtrează după utilizatorul care deține procesul)
    - Comandă terminal: pgrep -u root apache
  - -a (afișează întreaga linie de comandă folosită la lansare)
    - Comandă terminal: pgrep -a python

- pidof (PID of)
  - Folosință: Află rapid PID-ul unui program folosind numele exact al acestuia.
               Afiseaza PID-ul proceselor care au un anumit program (imagine de proces)
  - -s (returnează un singur PID, chiar dacă sunt mai multe instanțe)
    - Comandă terminal: pidof -s bash
  - -x (returnează și PID-ul scripturilor shell care rulează)
    - Comandă terminal: pidof -x myscript.sh

- pstree (Process Tree)
  - Folosință: Vizualizarea ierarhiei sub formă de arbore.
  - -p (afișează PID-urile lângă numele proceselor)
    - Comandă terminal: pstree -p
  - -a (afișează argumentele cu care au fost pornite procesele)
    - Comandă terminal: pstree -a
  - -h (evidențiază procesul curent și părinții săi)
    - Comandă terminal: pstree -h

- pmap (Process Map)
  - Folosință: Afiseaza harta memoriei unui proces (zonele de memorie ocupate de acesta)
  - -x (afișează detalii extinse despre utilizarea memoriei)
    - Comandă terminal: pmap -x $(pidof bash)
  - -d (afișează formatul de dispozitiv/device)
    - Comandă terminal: pmap -d 1234

- lsof (List Open Files)
  - Folosință: Identificarea fisierele deschide de un proces
  - -p (listează fișierele deschise de un anumit PID)
    - Comandă terminal: sudo lsof -p 1234
  - -u (listează fișierele deschise de un anumit utilizator)
    - Comandă terminal: sudo lsof -u student
  - -i (listează conexiunile de rețea active)
    - Comandă terminal: sudo lsof -i

2. Utilitare care monitorizeaza in timp real procesele sistemului

- top (Table of Processes)
  - Folosință: Monitorizarea dinamică a consumului de resurse.
  - -u (afișează doar procesele unui utilizator specific)
    - Comandă terminal: top -u student
  - -d (setează intervalul de timp pentru actualizarea datelor)
    - Comandă terminal: top -d 5
  - -p (monitorizează strict unul sau mai multe PID-uri date)
    - Comandă terminal: top -p 1,1234

- htop (Interactive Process Viewer)
  - Folosință: Monitorizare interactivă.
  - -u (afișează procesele unui utilizator anume)
    - Comandă terminal: htop -u student
  - -d (setează întârzierea actualizării în zecimi de secundă)
    - Comandă terminal: htop -d 100

- iotop (I/O Top)
  - Folosință: Monitorizarea utilizării discului (I/O).
  - -o (afișează doar procesele care fac activitate pe disc în acel moment)
    - Comandă terminal: sudo iotop -o
  - -u (afișează doar procesele unui utilizator)
    - Comandă terminal: sudo iotop -u root
  - -b (batch mode - util pentru a salva datele într-un fișier)
    - Comandă terminal: sudo iotop -b -n 3

- iostat (parte din sysstat)
  - Folosință: Statistici despre utilizarea CPU și a dispozitivelor de stocare.
  - -d (afișează doar statisticile despre discuri)
    - Comandă terminal: iostat -d
  - -c (afișează doar statisticile despre CPU)
    - Comandă terminal: iostat -c
  - [interval] [număr] (actualizează datele la X secunde de Y ori)
    - Comandă terminal: iostat 2 5

## 4.2.3: Starea proceselor

- un proces are o stare care arata daca acesta ruleaza sau nu pe procesor
- un proces are nevoie de minim un procesor pentru a rula
- cand sunt mai multe procese decat procesoare, un proces ruleaza, iar altul asteapta
Def. Procesul planificat (scheduled) = procesul care ruleaza pe un procesor.
Def. Procesul blocat (sleeping) = procesul care asteapta operatii de input / output.
- starea proceselor se pot verifica cu utilitare de monitorizare
  - putem vedea daca un proces e blocat si cauza pentru care a fost blocat
  - sau sa vedem cat de multe procese sunt active (ready), gata sa ruleze  

Exemplu:
student@uso:~$ ps -e -o pid,cmd,state,time,%cpu --sort -%cpu
PID     CMD                           S     TIME       %CPU
8637    /usr/bin/python3 /usr/bin/u   S     00:00:22   3.6
9042    /usr/lib/snapd/snapd          S     00:00:05   1.2
1221    /usr/bin/gnome-shell          S     00:04:03   0.4
2717    /usr/lib/firefox/firefox -c   S     00:02:05   0.3
2637    /usr/lib/firefox/firefox -n   S     00:02:01   0.2

Stari ale proceselor:

- R (Running / Runnable) - Regula Generală
  - Procesul fie rulează pe procesor în acest moment, fie se află în coada de așteptare (ready), 
    fiind gata să fie executat imediat ce îi vine rândul.
  - Comandă terminal: ps -eo pid,state,cmd | grep " R"
  - Exemplu: Un script care face calcule matematice intense va fi aproape mereu în starea R.

- S (Interruptible Sleep) - Regula Generală
  - Procesul așteaptă un eveniment (apasarea unei taste, un semnal, un interval de timp) 
    pentru a continua. Poate fi trezit de un semnal.
  - Comandă terminal: ps -eo pid,state,cmd | grep " S"
  - Exemplu: Comanda `sleep 100` va sta în starea S până expiră timpul sau primește 
    un semnal (ex. Ctrl+C).

- D (Uninterruptible Sleep) - Regula Generală
  - Procesul așteaptă o resursă hardware (I/O) și NU poate fi trezit sau omorât 
    până nu primește acea resursă.
  - Comandă terminal: ps -eo pid,state,cmd | grep " D"
  - Exemplu: Un proces care încearcă să citească de pe un CD-ROM zgâriat sau un 
    disc de rețea deconectat.

- T (Stopped) - Regula Generală
  - Procesul a fost suspendat manual de către utilizator sau de un alt proces.
  - Comandă terminal: ps -eo pid,state,cmd | grep " T"
  - Exemplu: Un proces trimis în fundal prin apăsarea tastelor Ctrl+Z.

- Z (Zombie) - Regula Generală
  - Procesul a terminat execuția (este mort), dar încă ocupă un loc în tabela 
    de procese deoarece părintele nu i-a eliberat structura.
  - Comandă terminal: ps -eo pid,state,cmd | grep " Z"
  - Exemplu: Un proces copil care s-a terminat înainte ca părintele să apeleze funcția `wait()`.

- I (Idle) - Regula Generală
  - Procese de tip kernel thread care nu sunt active în acest moment și nu influențează 
    sarcina sistemului (load average).
  - Comandă terminal: ps -eo pid,state,cmd | grep " I"
  - Exemplu: kworker (fire de execuție ale kernelului care așteaptă de lucru).

Caracterele adiționale:
  <: Proces cu prioritate mare (nice negativ).
  N: Proces cu prioritate mică (nice pozitiv).
  L: Proces care are pagini de memorie blocate în RAM.
  s: Proces care este lider de sesiune (ex. un shell).
  l: Proces multi-threaded (are mai multe fire de execuție).
  +: Proces care rulează în prim-plan (foreground).
Obs. S+ este un proces pornit de în terminal care așteaptă o comandă.
     R+, este procesul care tocmai "muncește" vizibil pe ecran.

- un sistem este cu atat mai incarcat cu cat are mai multe procese gata sa ruleze (ready / runable)
Obs. Utilitarul `uptime` ne afisează încărcarea unui sistem în ultimul minut, în ultimele 5 minute si în ultimele 15 minute.
Ex. 
  student@uso:~$ uptime
  13:48:40 up 9 days 16:13,  5 users,  load average: 1.61, 2.05, 2.81
Obs. Utilitarul `top` afiseaza in partea de sus informatii despre incarcarea sistemului

## 4.2.4: Prioritatea proceselor

- procesele cu prioritate mai buna ruleaza mai des si mai mult timp pe procesor 
- prioritatea unui proces este afectata de comportamentul acestuia
- se poate schimba prioritatea unui proces prin modificarea atributului `nice` al procesului
  - o val nice mai mare inseamna ca procesul este mai "dragut" cu celelalte si le lasa sa fie planificate
  - o val mai mica inseamna ca e mai putin dragut, si le va lua fata altor procese
- un proces porneste cu o valoare `nice` = 0, neutra
- val poate fi modificata la pornirea procesului (load-time) sau cand ruleaza (run-time)
Obs. Un user neprivilegiat, poate doar creste valoarea `nice` a procesului pe care il detine, 
     adica poate doar slabi prioritatea procesului.
Obs. Doar un user privilegiat poate scadea valoarea si sa ii imbunatateasca prioritatea.

Utilitarul `nice`
  - folosit pentru a modifica prioritatea unui proces la pornire (load-time)

Utilitarul `renice`
  - folosit pentru a modifica prioritatea unui proces la rulare (run-time)

Obs. Comanda `renice` poate fi folosita de un user neprivilegiat doar pentru a cteste val nice a procesului sau.
Obs. Pentru scaderea valorii nice folosim contul privilegiat cu ajutorul `sudo`.
Obs. La fel, si `nice` poate porni un proces cu valoare modificata.

## 4.3: Ierarhia de procese

- un proces e creat la load-time dintr-ul fisier executabil, dupa aceea, 
  ii sunt acordate resurse (timp de procesor si zone de memorie), apoi ruleaza (run-time)
Obs. Crearea unui proces dintr-un executabil se mai numeste si loading.
Obs. Momentul crearii se mai numeste si load-time.

- un proces este creat din alt proces (proces parinte)
- un proces parinte poate crea oricate procese copil ii permit resursele sistemului
- un proces poate avea un singor proces parinte

- procesul parinte foloseste o interfata specifica a OS, pentru crearea unui alt proces
In Linux: 
  - foloseste grupul de apel fork() si exec()
In Windows:
  - foloseste CreatePrrocess()

Apeluri si semnificatia lor:

fork()
  - Creează o copie identică a procesului părinte. Procesul copil primește 
    un PID nou, dar moștenește tot (variabile, fișiere deschise).
  - Caracteristică: Este singura funcție care returnează de două ori: 
    0 în procesul copil și PID-ul copilului în procesul părinte.
  - Comandă terminal: ps --forest (pentru a vedea rezultatul 
    vizual al fork-urilor succesive).

exec() 
  - Înlocuiește imaginea procesului curent cu un program nou 
    (de exemplu, înlocuiește shell-ul cu `ls`).
  - Caracteristică: Procesul NU primește un PID nou; PID-ul rămâne același, 
    dar conținutul procesului se schimbă complet.
  - Exemplu: Când scrii `ls` în terminal, shell-ul face `fork()` (se multiplică), 
    iar copia face `exec()` (se transformă în `ls`).

wait() / waitpid() 
  - Suspendă execuția părintelui până când unul sau un anumit proces 
    copil se termină.
  - Caracteristică: Este mecanismul prin care părintele colectează 
    "statusul de ieșire" al copilului.
    Dacă părintele nu apelează `wait()`, copilul devine Zombie (Z).
  - Comandă terminal: ps -el (vezi coloana S pentru starea Z).

exit()
  - Termină execuția procesului curent și eliberează majoritatea resurselor ocupate.
  - Caracteristică: Trimite un cod de eroare (0 pentru succes, >0 pentru eroare) 
    către părinte.
  - Comandă terminal: echo $? (afișează codul de ieșire al ultimului proces terminat).

clone()
- O versiune mai versatilă de `fork()` folosită în 
  Linux pentru a crea fire de execuție (threads).
- Caracteristică: Permite copilului să împartă (share) 
  aceeași memorie cu părintele, nu doar să o copieze.
- Comandă terminal: ps -fL (pentru a vedea thread-urile create prin clone).

getpid() / getppid()
- Apeluri prin care un proces își întreabă sistemul propriul PID sau PID-ul părintelui său.
- Caracteristică: Sunt folosite de procese pentru a-și identifica "identitatea" în sistem.

Obs. Procesul care creeaza un nou proces este `shell`.
  - poate fi grafic (Ex. Windows Esplorer)
  - poate fi in linia de comanda (Bash)

Moduri in care un proces poate fi incheiat:

- Terminare Voluntară
  - Procesul își termină codul sau execută `exit()`.
  - Exemplu: `exit 0`

- Terminare Involuntară (Kill)
  - Forțată de utilizator/sistem prin semnale.
  - Comandă: `kill -[semnal] [PID]`
  - Exemplu: `kill -9 1234`

- Terminare prin Eroare (Crash)
  - Acțiuni nevalide (ex: Segmentation fault).
  - Exemplu: Accesarea memoriei interzise.

- Terminare prin Sistem (OOM - Out Of Memory)
  - Kernel-ul închide procesul din lipsă de RAM.
  - Comandă: `dmesg | grep "OOM"`
    - Afișează mesajele din jurnalul kernelului care conțin eroarea Out Of Memory

## 4.3.1: Ierarhia de procese in Linux/Unix

Utilitarul `pstree`
  - ne permite sa vedem ierarhia de procese

Steaguri:

- -p (show PIDs)
  - Afișează PID-ul lângă fiecare nume de proces.
  - Comandă terminal: pstree -p
  - Exemplu: pstree -p

- -u (show users)
  - Arată tranzițiile de utilizator (când un proces își schimbă proprietarul).
  - Comandă terminal: pstree -u
  - Exemplu: pstree -u

- -h (highlight)
  - Evidențiază procesul curent sau un proces specific.
  - Comandă terminal: pstree -h [PID]
  - Exemplu: pstree -h 10384

- -a / -A (arguments)
  - Afișează argumentele liniei de comandă folosite la pornire.
  - Comandă terminal: pstree -a
  - Exemplu: pstree -a

- [utilizator]
  - Afișează doar arborele proceselor ce aparțin unui utilizator.
  - Comandă terminal: pstree [nume_utilizator]
  - Exemplu: pstree student

Procesul init (PID 1)
  - Reprezintă rădăcina ierarhiei de procese (primul proces al sistemului).
  - Implementare actuală: systemd (majoritatea distribuțiilor Linux).
  - Rol: Pornește serviciile sistemului și procesele de bază.
Ierarhia de procese
  - Un proces are un singur părinte și poate avea oricâți copii.
  - Structură: init -> servicii/shell-uri -> alte procese.
Procese orfane
  - Def. Procese al căror părinte și-a încheiat execuția înaintea lor.
  - Mecanism: Sunt "adoptate" automat de procesul init, care devine noul lor părinte.

## 4.3.2: Ierarhia de procese in Windows

- la fel ca in Linux, si in Windows un proces creeaza alt proces
- ierarhia de procese are legaturi mai slabe ca in Linux
  - in Linux un proces parinte are privilegii specifice de comunicare cu un proces copil 
    (prin `pipe` de exemplu)
  - in Windows, un proces poate comunica in acelasi mod si cu unul cu care nu e conectat ierarhic
- un proces are o referinta (handle) catre un proces pe care l-a creat, dar acea referinta poate
  fi transferata altui proces, afectand ierarhia
Obs. Shell-ul Windows este un shell grafic reprezentat de procesul Explorer.

## 4.3.3: Foreground si background

- procesele deja existente ci cele nou create in shell folosesc simultan terminalul
- terminalul este modul in care user-ul poate transmite informatii la iesirea standard 
  si modul in care se afiseaza informatiile la iesirea standard
- procesele noi create si shell-ul afiseaza informatii la iesirea standard 
  - aceste afisari vor aparea pe terminal
- totusi, daca trimitem informatii la intrarea standard, prin terminal, 
  doar procesul nou creat in shell le va accesa

Obs. In foreground exista un singur proces care detine controlul intrarii in cadrul terminalului

Moodul de functionare al shell-ului:
1. shell-ul citeste de la intrarea standard (din terminal), comenzi introduse de user
2. shell-ul creeaza un nou proces pornind de la comanda introdusa
3. procesul nou creat ruleaza in foreground si are controlul terminalului 
  - are si controlul intrarii standard a terminalului
4. procesul nou creat isi incheie executia
  - shell-ul, in calitate de proces parinte, retine informatii despre incheierea executiei
5. shell-ul redobandeste controlul asupra terminalului si reincepe pasul 1

- problema apare daca procesul nou creat acapareaza terminalul si nu se incheie rapid
- solutia este un mod de folosire a terminalului: background
  - permite shell-ului rularea continua si crearea de mai multe procese
  - este modul prin care un proces nu mai are acces la informatii furnizate de utilizator
- pot exista oricat de multe procese in background
- in bg, procesele se pot gasi in doua stari:
  - ruland (running)
  - suspendate (stopped, suspended, paused)
Obs. Un proces suspendat nu se poate gasi in foreground (fg), ci doar in background (bg).
Obs. Un proces poate rula de la inceput in background sau poate fi transferat acolo dupa pornire.
Obs. Pt a rula un proces in bg, folosim `&` imediat dupa ce introducem comanda si parametri ei.

Utilitarul `jobs`:
  Def. Utilitar shell care afișează starea proceselor pornite în fundal sau suspendate din 
       terminalul curent, identificate prin ID-uri de job.
  Steaguri:
  - -l : Afișează PID-ul procesului alături de numărul job-ului.
    - Comandă terminal: jobs -l
  - -p : Afișează doar PID-urile proceselor.
    - Comandă terminal: jobs -p
  - -r : Afișează doar job-urile care sunt în starea "Running".
    - Comandă terminal: jobs -r
  - -s : Afișează doar job-urile care sunt în starea "Stopped".
    - Comandă terminal: jobs -s
  Exemplu probă:
  - student@uso:~$ firefox &
  - [1] 10533
  - student@uso:~$ jobs -l
  - [1]+ 10533 Running  firefox &
  Capcană:
  - Comanda jobs afișează doar procesele pornite din shell-ul curent. 
    - Într-un terminal nou, lista va fi goală.
  - Diferența PID vs Job ID: PID (ex: 10533) este global, Job ID (ex: [1]) este local shell-ului.

Obs. Un proces creat ca sa ruleze in fg, poate fi suspendat cu comanda `Ctrl + z` si va trece in bg.
Obs. Operatorul `&` duce in background un proces ruland (running), iar comada `Ctrl + z`
     il duce in background in starea suspendat.

Utilitare: fg și bg (Capitolul 4 - Procese)
  Steaguri:
  - [job_id] : Se folosește indexul job-ului (ex: %1, %2) pentru a ținti un proces specific.
    - Comandă terminal: fg %1
  - Exemplu probă:
    - student@uso:~$ sleep 100
    - ^Z
    - [1]+ Stopped sleep 100
    - student@uso:~$ bg %1
    - [1]+ sleep 100 &
    - student@uso:~$ jobs
    - [1]+ Running sleep 100 &
  - Capcană:
    - Un proces mutat cu Ctrl+Z este în starea **Stopped**. El NU rulează în 
      background până nu primește comanda `bg`.
    - În foreground, un proces "acaparează" terminalul. Orice comandă tastată (ex: `ls`) în 
      timp ce un proces rulează în foreground (ex: `sleep 100`) nu va fi interpretată de shell până când 
      procesul din foreground nu se termină sau este suspendat.

- Concurs:
  - Identificatori de Job: Sunt afișați între paranteze pătrate `[1]`, `[2]`. Se folosesc 
    cu simbolul `%` în fața cifrei pentru comenzile `fg` și `bg`.
  - Scenariu GUI: Dacă pornești o aplicație grafică (ex: `emacs`, `firefox`) fără `&`, 
    terminalul rămâne blocat. Soluția standard AcadNet: `Ctrl+Z` urmat de `bg`.
  - Închiderea Shell-ului: Dacă închizi terminalul, procesele active (și cele din 
    background) sunt de regulă omorâte (primesc semnalul SIGHUP).
  - Simboluri de stare în jobs:
    - + : Job-ul curent (cel mai recent modificat).
    - - : Job-ul imediat precedent celui curent.
Obs. 1) Simbolul + (Job-ul curent): Este ultimul job cu care ai interacționat (cel pornit 
        cel mai recent sau cel mai recent suspendat). Dacă scrii simplu `fg` sau `bg`, acesta este cel vizat.
     2) Simbolul - (Job-ul precedent): Este "rezerva". Dacă job-ul cu `+` se termină, cel 
        cu `-` îi va lua locul și va deveni noul job curent (+).
     3) Clarificare: Cel cu `-` NU este încheiat și nici nu "urmează" să pornească singur. 
        Ambele pot rula simultan în background. `-` indică doar ordinea de prioritate în stiva shell-ului.

- Concurs (Sinteză Grile):
  - Transfer de stare: Foreground (Running) --Ctrl+Z--> Background (Stopped) --bg--> 
    Background (Running) --fg--> Foreground (Running).
  - Execuție simultană: Pot exista oricâte procese în background în starea "Running", 
    dar numai unul poate fi în foreground.
  - Prioritate terminal: Doar procesul din foreground are acces la "Standard Input" 
    (poate citi ce scrii la tastatură).

## 4.3.4: Procesul init

- aflat in varful ierarhiei proceselor
Obs. Spunem ca un sistem Lunux a bootat in momentul crearii procesului init.

Roluri:
1. pornirea proceselor initiale
2. intretinerea sistemului 
  - adopta procesele orfane

Obs. Daca procesul init moare sau este oprit, sistemul devine neutilizabil.
Solutie: Pe sistemul Ubuntu a aparut solutia folosirii mai multor procese init
  - cate un proces pentru fiecare sesiune

## 4.4: Procese si fisiere

- fisierele sunt folosite pentru a stoca informatii care urmeaza sa fie accesate,
  prelucrate si transferate prin diverse operatii pe care le efectueaza user-ul

Acces și Gestiune
- Conceptul de Handle:
  - Definiție: Este un "mâner" sau o referință prin care un proces manipulează un fișier.
- Descriptorul de fișier (File Descriptor - FD):
  - Definiție: Un număr întreg (index) dintr-o tabelă internă a procesului (Tabela Descriptorilor).
  - Rol: Face legătura între proces și fișierul fizic de pe disc.
- Descriptori Standard:
  - 0 (stdin) : Intrarea standard (tastatura).
  - 1 (stdout) : Ieșirea standard (ecranul pentru rezultate).
  - 2 (stderr) : Eroarea standard (ecranul pentru mesaje de eroare).

- Concurs:
  - Tabela Descriptorilor: Fiecare proces are propria tabelă. Dacă două procese 
    deschid același fișier, fiecare va avea propriul descriptor în tabela sa.
  - Legătura cu Redirectările: Când scrii `2> eroare.txt`, îi spui shell-ului: 
    "ia tot ce procesul trimite către descriptorul 2 și mută în fișier".
  - Identificare: În Linux, poți vedea descriptorii unui proces în directorul 
    `/proc/[PID]/fd/`.

- Concurs :
  - Orice acces la un fișier se face printr-un proces. Fișierul nu se citește singur.
  - "Handle" este interfața software, "Descriptorul" este numărul (indexul) din tabelă.
  - În C, `fopen()` returnează un handle (`FILE *`), care în spate folosește 
    un descriptor de fișier (un simplu număr precum 3, 4, 5...).

## 4.4.1: Descriptori de fisiere

- un descriptor de fisiere identifica pentru un proces fisierul pe care il opereaza
- un proces, cand vrea sa acceseze un fisier, porneste de la descriptorul de fisiere, 
  acceseaza intrarea aferenta in tebela de descriptori de fisiere si se foloseste de 
  informatiile de acolo pentru a folosi fisierul
- tabela de descriptori are dimensiune limitata in Linux (1024 intari)
  - previne folosirea abuziva de resurse ale sistemului
  -> previne un atac de tip denial of service
  -> un proces nu poate deschide un numar infinit de fisiere (maxim 1024)

- Utilitarul `lsof` (List Open Files)
  - afișează toate fișierele și resursele deschise de procesele din sistem.
  - Steaguri:
    - -p [PID] : Listează fișierele deschise de un proces specific (identificat prin PID).
      - Comandă terminal: lsof -p 9585
    - -u [user] : Listează fișierele deschise de un anumit utilizator.
      - Comandă terminal: lsof -u student
    - -i : Afișează fișierele de rețea (conexiuni active).
      - Comandă terminal: lsof -i
  - Interpretare Output (Coloana FD):
    - 0, 1, 2 : Descriptorii standard (stdin, stdout, stderr).
    - u, r, w : Modul de acces (u = read/write, r = read, w = write).
    - txt : Fișierul executabil al procesului (codul sursă compilat).
    - mem : Biblioteci partajate (shared libraries) încărcate în memorie (.so).
    - cwd : Directorul curent de lucru (Current Working Directory).
  - Capcană:
    - Primul descriptor disponibil pentru un fișier nou deschis de utilizator este `3`, 
      deoarece 0, 1 și 2 sunt ocupate automat la pornirea procesului.
    - Chiar dacă procesul rulează același program (ex: `bash`), descriptorii 0, 1, 2 
      pot pointa către terminale diferite (ex: `/dev/pts/1` vs `/dev/pts/2`).

- Concurs:
  - Alocarea descriptorilor: Sistemul de operare alocă întotdeauna `cel mai mic index disponibil` 
    în tabela de descriptori atunci când un proces deschide un fișier nou.
  - Izolare: Fiecare proces are propria tabelă. Descriptorul 3 din procesul A nu 
    are nicio legătură cu descriptorul 3 din procesul B.
  - Tipuri de resurse: `lsof` arată că un proces nu deschide doar fișiere text, ci și:
    - Biblioteci sistem (`/lib/.../libc.so`)
    - Terminale (`/dev/pts/X`)
    - Directoare (`cwd`, `rtd`)
  - Identificator standard: Dacă în output vezi un număr urmat de 'u' (ex: `255u`), 
    acela este un descriptor de fișier activ în tabelă.

Procese și Editoare
- Mod de lucru: Editoarele (Vim, Gedit, Emacs) NU mențin fișierul deschis permanent în timpul editării.
  - Citesc fișierul în memorie (RAM) într-o structură numită buffer.
  - Modificările se fac direct în RAM pentru viteză (discul este mult mai lent).
  Obs. Fișierul de pe disc este deschis și închis rapid doar în momentul salvării (save).
- Fișiere Swap (.swp): Pentru a preveni pierderea datelor în caz de crash, editoarele creează 
  un fișier temporar pe disc care stochează modificările nesalvate.
- Interpretare lsof pentru Vim:
  - În `lsof -p [PID]`, nu vei vedea fișierul `a.txt` deschis cu un descriptor numeric (3, 4 etc.).
  - Vei vedea în schimb fișierul swap (ex: `.a.txt.swp`) alocat de obicei pe descriptorul 3.

- Utilitar: pidof 
  - afișează ID-ul procesului (PID) pentru un program care rulează, căutându-l după nume.
  - Steaguri:
    - -s : Returnează un singur PID (Single), chiar dacă rulează mai multe instanțe ale programului.
      - Comandă terminal: pidof -s vim
  - Exemplu probă:
    - student@uso:~$ pidof vim
    - 11414

- Concurs:
  - Capcană: La întrebarea "Are editorul Vim fișierul message.txt deschis în tabela de descriptori în timpul editării?", 
    răspunsul corect este NU. Are deschis un fișier temporar (swap), nu fișierul original.
  - Avantaj buffer: Performanță ridicată. Editarea direct pe disc ar fi ineficientă 
    din cauza latenței hardware-ului de stocare.
  - Securitate/Recuperare: Fișierul `.swp` este cel care permite recuperarea 
    textului dacă terminalul se închide accidental.

- Concurs (Sinteză Grile):
  - lsof -p [PID] : Este metoda prin care verificăm ce "vede" un proces în timp real.
  - Descriptorul 3u : În exemplul cu Vim, litera 'u' (read/write) indică faptul 
    că fișierul swap este deschis pentru ambele operații.

## 4.4.2: Redirectarea  in/din fisiere

- descriptorii de fisiere pot sa refere terminalul, cum fac descriptorii standard (0, 1, 2),
  sau pot sa refere fisiere
- legaturile descriptorilor standard cu terminalul nu sunt fixe si pot fi modificate
  -> procesul se numeste redirectare
Def. Redirectarea = modificarea unor descriptori standard, astfel incat sa refere fisiere, nu terminalul.

- Utilitar: lshw
  - listează informații detaliate despre componentele hardware ale calculatorului.
  Steaguri:
  - -short : Afișează hardware-ul într-un format compact, sub formă de listă.
    - Comandă terminal: lshw -short
  - -html : Generează un raport hardware în format HTML (util pentru documentare).
    - Comandă terminal: lshw -html > hardware.html
  - -C [class] : Filtrează după o anumită clasă de hardware (ex: network, memory).
    - Comandă terminal: lshw -C network

- Concurs (Redirectări):
  - Operatorul > : Modifică descriptorul 1 (stdout) al procesului `lshw`.
  - Efect: În loc ca datele despre hardware să fie afișate pe ecran (terminal), 
    ele sunt scrise în fișierul `lshw.out`.
  - Comandă terminal: lshw > lshw.out
  - Capcană AcadNet: Dacă fișierul `lshw.out` există deja, operatorul `>` îl va `suprascrie` 
    complet (șterge tot ce era înainte). Pentru a adăuga la finalul fișierului, se folosește `>>`.
- Concurs (Sinteză Grile):
  - lshw vs lsof: `lshw` se ocupă de hardware (discuri, CPU), în timp ce 
    `lsof` se ocupă de fișiere deschise de procese.
  - Permisiuni: De cele mai multe ori, `lshw` necesită drepturi de administrator
    (root) pentru a accesa toate detaliile hardware.
    - Comandă terminal: sudo lshw

## 4.5: Operatii cu procese. Interactiunea intre procese

- procesele dau nastere la alte procese, iar shell-ul este de obicei procesul parinte
  -> se folosesc comenzi care creeaza procese
  -> procesul ruleaza pana la incheierea sa, folosind resursele sistemului

## 4.5.1: Incheierea unui proces

Exista urmatoarele situatii pentru incheierea unui proces:
  - atingerea sfarsitului rpogramului (incheierea functiei main() in C)
  - pelul unei rutine de incheiere (Ex. functia exit() in C)
  - atingerea unei conditii neasteptate
    - Ex. accesare unei zone invalide de memorie, rularea unei comenzi invalide etc.
  - omorarea / terminarea de un alt proces

Terminarea (omorarea)
  - se realizeaza de catre un alt proces cu permisiuni
    - procesul poate apartine user-ului curent sau administratorului
  - are loc prin transmiterea unui semnal catre acel proces

Obs. Terminarea unui proces in Windows are loc prin transmiterea unei notificari numite `exceptie`, de la un proces la altul.

Obs. La incheierea unui proces, procesul incheiat trimite proceului parinte doua informatii:
  -> cum si-a incheiat executia (exit status)
  -> un cod de iesire (exit code)
    - val 0 pentru succes si val cuprinse intre 1-255 pentru eroare

Obs. Variabila $? contine codul de iesire al ultimei comenzi rulate in terminal.
  Ex.
   student@uso:~$ grep student /etc/passwd > /dev/null
   student@uso:~$ echo $?
   0
   student@uso:~$ grep profesor /etc/passwd > /dev/null
   student@uso:~$ echo $?
   1

Variabile Speciale Bash
  Def. Variabile predefinite de shell care stochează informații despre starea proceselor și a argumentelor.
  - Lista Variabilelor:
    - $? : Codul de retur al ultimei comenzi executate. 0 înseamnă succes, orice alt număr indică o eroare.
      - Exemplu: ls /folder_invalid; echo $?
    - $! : PID-ul ultimului proces trimis în background folosind operatorul &.
      - Exemplu: sleep 100 & echo $!
    - $$ : PID-ul procesului shell curent în care lucrezi.
      - Exemplu: echo $$
    - $0 : Numele scriptului sau al shell-ului care rulează.
      - Exemplu: echo $0
    - $# : Numărul total de argumente transmise unei comenzi sau script.
      - Exemplu: ./script.sh arg1 arg2 (afișează 2)
    - $1, $2, ... : Valoarea fiecărui argument în ordinea introducerii lor.
      - Exemplu: echo $1 (afișează primul argument)
    - $@ : Reprezintă toate argumentele primite, tratate ca elemente individuale.
    - $* : Reprezintă toate argumentele primite, concatenate într-un singur șir de caractere.

## 4.5.2: Semnale

Obs. Un semnal este identificat printr-un număr sau un nume.
Def. Mecanisme de interacțiune și notificare între procese.
- Procesele comunică între ele pentru a semnala situații deosebite.
- Pentru ca un proces să poată trimite semnale, trebuie să aibă permisiuni:
  -> Trebuie ca ambele procese să aparțină aceluiași user SAU
  -> Să aparțină user-ului root.
Obs. Semnalele pot fi folosite și pentru omorârea proceselor.

- Utilitar: kill 
  - Rol: Trimite un semnal către un proces identificat prin PID.
  - Steaguri:
    - -l : Listează toate semnalele disponibile.
      - Comandă terminal: kill -l
    - -s [semnal] : Specifică semnalul prin nume.
      - Comandă terminal: kill -s SIGKILL 1234
    - -[număr/nume] : Modul scurt de a trimite un semnal.
      - Comandă terminal: kill -9 1234
    - -a : Permite trimiterea semnalelor proceselor care nu aparțin utilizatorului curent (necesită root).
      - Comandă terminal: sudo kill -a -9 1234

- Utilitar: pkill
  - Rol: Trimite semnale bazat pe atributele procesului (nume, user etc.).
  - Steaguri:
    - -u [user] : Targetează procesele unui anumit utilizator.
      - Comandă terminal: pkill -u student sleep
    - -x : Potrivire exactă a numelui (Exact match).
      - Comandă terminal: pkill -x bash
    - -n : Trimite semnal doar celui mai recent proces pornit (Newest).
      - Comandă terminal: pkill -n python
    - -o : Trimite semnal doar celui mai vechi proces pornit (Oldest).
      - Comandă terminal: pkill -o firefox
    - -P [PPID] : Targetează procesele care au un anumit părinte.
      - Comandă terminal: pkill -P 1

- Utilitar: killall 
  - Rol: Omoară toate procesele care au un anumit nume.
  - Steaguri:
    - -i : Cere confirmare înainte de a omorî procesul (Interactive).
      - Comandă terminal: killall -i firefox
    - -I : Ignoră diferența între litere mari și mici (Ignore case).
      - Comandă terminal: killall -I FIREFOX
    - -u [user] : Omoară procesele cu numele X doar dacă aparțin user-ului Y.
      - Comandă terminal: killall -u student vim
    - -v : Afișează detalii despre succesul operațiunii (Verbose).
      - Comandă terminal: killall -v sleep

- Utilitar: skill (Menționat în USO ca alternativă pe alte sisteme)
  - Rol: Semnalizează sau schimbă prioritatea proceselor.
  - Steaguri:
    - -t [tty] : Targetează toate procesele atașate unui anumit terminal.
      - Comandă terminal: skill -KILL -t /dev/pts/1
    - -u [user] : Targetează toate procesele unui utilizator.
      - Comandă terminal: skill -STOP student
    - -p : Targetează procesul după PID (similar cu kill).
      - Comandă terminal: skill -CONT -p 1234

- Concurs (Sinteză Capcane):
  - Diferența critică: `kill` vrea PID (numeric), `killall` și `pkill` vor Nume (text).
  - Semnalul implicit: Toate trimit **15 (SIGTERM)** dacă nu specifici altceva.
  - Atenție la pkill: Dacă scrii `pkill fi`, va omorî și `firefox` și `find` (orice conține "fi"). 
    Folosește `-x` pentru siguranță.

  Semnale Critice:

    - SIGINT (2)
      - Rol: Întrerupe un proces de la tastatură (Interrupt).
      - Combinație taste: Ctrl+C
      - Comandă terminal: kill -SIGINT $(pidof sleep)
    
    - SIGQUIT (3)
      - Rol: Termină un proces și generează un core dump (Quit).
      - Combinație taste: Ctrl+\
      - Comandă terminal: kill -3 1234

    - SIGKILL (9)
      - Rol: Omoară forțat procesul (Kill). NU poate fi ignorat.
      - Combinație taste: Nu există.
      - Comandă terminal: kill -9 1234

    - SIGTERM (15)
      - Rol: Cere procesului să se închidă frumos (Terminare implicită).
      - Combinație taste: Nu există.
      - Comandă terminal: kill 1234

    - SIGCONT (18)
      - Rol: Continuă execuția unui proces care a fost suspendat.
      - Combinație taste: Nu există (corespunde comenzii `bg` sau `fg`).
      - Comandă terminal: kill -SIGCONT 1234

    - SIGSTOP (19)
      - Rol: Suspendă imediat procesul (Stop). NU poate fi ignorat.
      - Combinație taste: Nu există.
      - Comandă terminal: kill -19 1234

    - SIGTSTP (20)
      - Rol: Suspendă procesul de la tastatură (Terminal Stop).
      - Combinație taste: Ctrl+Z
      - Comandă terminal: kill -SIGTSTP $(pidof sleep)

 Concurs (Sinteză Grile):
- Semnale de neignorat: SIGKILL (9) și SIGSTOP (19). Orice alt semnal poate 
  fi interceptat sau ignorat de programator.
- Diferența SIGINT vs SIGTERM: SIGINT vine de la terminal (Ctrl+C), SIGTERM 
  este cererea sistemului de a închide procesul.
- Identificare: Dacă o grilă întreabă de semnalul 10, te uiți în `kill -l` 
  și vezi că este SIGUSR1 (semnal definit de utilizator).

Pe scurt, atunci când vrem să omorâm un proces aflat în foreground folosim:
• combinatia de taste `Ctrl+c`
• combinatia de taste `Ctrl+\`
• trimiterea semnalului SIGKILL din alt terminal

## 4.5.3: Inlantuirea comenzilor

- folosim operatori de inlantuire care ne permit sa rulam mai multe procese unul dupa altul 
    si sa folosim o singura linie de comanda

1. Operatorul de inlantuire neconditionata (`;`)
  - ruleaza doua comenzi una dupa alta, indiferent de codul de iesire
2. Operatorii de inlantuire conditionata (`&&` (AND) & `||` (OR))
  - conditioneaza rularea celei de-a doua comenzi de codul de iesire al primei comenzi
  -> comm1 || comm2 ruleaza comanda 2 doar daca comanda 1 s-a incheiat cu insucces
  -> comm1 && comm2 ruleaza comanda 2 doar daca comanda 1 s-a incheiat cu succes

Ex.
  student@uso:~/.../code/04-process/main-args$ make && ./main_args
Ce se intampla in linia de comanda:
  - executabilul main_args ruleaza (./) doar daca a reusit comanda de compilare `make`
  - main_args = program scris in C folosit pentru a demonstra argumentele liniei de comanda
    - afiseaza numarul de argumente primite si continutul acestora (vectorul de argumente `argv`)

 Utilitarul `make` 
  - erifică ce fișiere sursă au fost modificate și compilează doar părțile necesare pentru a obține executabilul.
 Steaguri:
    - -f [file] : Specifică un alt fișier în loc de cel implicit ("Makefile").
      - Comandă terminal: make -f MyMakefile
    - -j [n] : Rulează compilarea în paralel pe mai multe nuclee (Jobs). Foarte util pentru viteza.
      - Comandă terminal: make -j 4
    - -C [dir] : Schimbă directorul înainte de a căuta Makefile-ul.
      - Comandă terminal: make -C /home/student/proiect
    - -n (dry-run) : Afișează comenzile care ar fi executate, fără a le rula efectiv.
      - Comandă terminal: make -n
  - Target-uri comune (Convenții):
    - make clean : Șterge fișierele obiect și executabilele rezultate din compilările anterioare.
    - make all : Target-ul implicit care compilează tot proiectul.

- Alte utilitare relevante pentru compilare:
  - gcc (GNU Compiler Collection) : Compilatorul propriu-zis pentru C/C++.
    - Steaguri critice:
      - -o [nume] : Specifică numele executabilului final.
        - Comandă terminal: gcc main.c -o main_args
      - -Wall : Afișează toate avertismentele (Warnings All).
      - -g : Include informații pentru debugging (necesar pentru GDB).
  - gdb (GNU Debugger) : Utilitar pentru depanarea programelor pas cu pas.
  - ld (Linker) : Combină fișierele obiect într-un executabil (make/gcc îl apelează automat).

## 4.5.4: Comunicarea prin pipe-uri

- cand folosim inlantuiri urmarim transferul de date de la o comanda la alta
Transferul folosind un fisier:
  - o comanda redirecteaza iesirea spre acel fisier, iar alta comanda redirecteaza intrarea
  - Ex. 
    student@uso:~$ ps -e --no-header > out   
    student@uso:~$ wc -l < out
    191
    - redirectam iesirea comenzii `ps` in fisierul out
    - folosim fisierul out ca intrare pentru `wc`
    -> aflam cate procese sunt active in sistem, numarand liniile afisate de comanda ps
    Obs. --no-header face ca ps sa nu mai afiseze capul tabelar.

Utilitarul `wc` (Word/Line/Character/Byte Count)
  -afișează implicit numărul de linii, cuvinte și octeți (bytes) dintr-un fișier
    - Ex. wc date.txt
  Steaguri:
  - wc -l: (Lines) Afișează doar numărul de linii (cea mai folosită opțiune)
    - Exemplu: wc -l /etc/passwd
  - wc -w: (Words) Afișează doar numărul total de cuvinte
    - Exemplu: wc -w eseuri.txt
  - wc -c: (Bytes) Afișează numărul total de octeți (bytes)
    - Exemplu: wc -c imagine.jpg
  - wc -m: (Characters) Afișează numărul de caractere (important pentru fișiere 
            cu caractere speciale/Unicode unde 1 caracter != 1 byte)
    - Exemplu: wc -m text_romana.txt
  - wc -L: (Max line length) Afișează lungimea celei mai lungi linii din 
            fișier (numărul de caractere)
    - Exemplu: wc -L configuratie.conf

Operatorul `|` (pipe)
  - transfera iesirea standard a unei comenzi catre intrarea standard a celeilalte comenzi
  - Ex. 
    student@uso:~$ ps -e --no-header | wc -l
    192
    -> aflam cate procese sunt active in sistem, numarand liniile afisate de comanda ps
    Obs. Spre deosebire de prima implementare (unde contorul este 191 de procese), 
in a doua implementare este 192.
      Asta rezulta din faptul ca in prima implementare, `ps` nu numara procesul `wc`, 
deoarece `wc` incepe cand fisierul out cu procese din `ps` este completat.
      In a doua implementare, `ps` si `wc` ruleaza simultan, deci `ps` vede cu un proces mai mult (192).

Exemplu de inlantuire de comenzi cu `|`:
  student@uso:~$ grep -rwc FILE /usr/include/ | grep -v ':0' | sort -n -t ':' -k2 | tail -5
  Explicatie:
  1. grep -rwc FILE /usr/include/
    - cauta recursiv (-r) cuvantul intreg (-w) "FILE" si le numara (-c) aparitiile in directorul specificat
    Obs. Când rulezi grep -c (count) pe mai multe fișiere, formatul standard de afișare 
         este întotdeauna: nume_fisier:numar_aparitii   # coloana1(k1):coloana2(k2)
  2. grep -v ':0'
    - elimina (-v) liniile care se termina in ":0" (adica ignora 
      fisierele in care nu a gasit niciul "FILE" scris)
  3. sort -n -t ':' -k2
    - sorteaza numeric (-n), folosind ":" ca separator de coloane (-t ':') si se 
      uita la a doua coloana (-k2) adica la numarul de aparitii
  4. tail -5
    - pastreaza doar ultimele 5 aparitii din lista sortata, adica 
      fisierele cu cele mai multe aparitii

## 4.6: Interactivitatea Proceselor

Def. Procesele interactive = procese care au nevoie de informatii (prin mouse sau 
     tastatura) de la utilizator si ofera informatii pe ecran.
Def. Procesele neinteractive = ruleaza fara interventia utilizatorului.
  - se mai numesc si `procese batch`

Obs. Shell-ul e unul dintre cele mai importante procese interactive.
  - poate fi grafic sau in linia de comanda

## 4.6.1: Terminale

- terminalul intermediaza transmiterea intrarii (0) si iesirii (1) de la utilizator la shell
- e localizat in FSH in /dev, si se acceseaza cu comanda `tty`
- procesul de rulate al terminalului se poate vedea cu `ps`
- procesele desfasurate simultan in shell vor impartii iesirea standard (1)
- poate exista un singur proces in foreground, si doar acesta are acces la intrarea standard (0)

## 4.6.2: Procesele neinteractive

- procesele neinteractive sunt utile pentru mentinerea bunei-functionari a sistemului
  -> nu necesita standard input 
- un background process nu are acces la terminal pentru intrarea standard
  -> acesta ruleaza in general interactiv
- un proces care ruleaza in background poate fi detasat de terminal
Def. Proces detasat = proces care a pierdut orice legatura cu terminalul (standard 
    input, output si error nu mai refera terminalul).
  - legatura nu mai poate fi restaurata
  - descriptorii standard ai unui proces detasat nu mai refera ternalul, ci refera 
    fisiere sau alte tipuri de intrare precum (pipe-uri, sockets)

4.6.3: Procese daemon

- se mai numesc servicii (ca si in Windows)
  - gestiunea serviciilor in Linux se face cu comanda `service`
- ruleaza in background, neinteractiv, detasate de terminal
- are ca proces parinte procesul init
- descriptorii standard refera intrarea /dev/null
- ofera un anumit serviciu de sistem
  - Ex. procesul `atd`
    - proces daemon care planifica executarea altor procese la un moment dat

Interactiunea cu procesele daemon se face prin:
  - semnale
  - fisiere de configurare
  - fisiere de tip jurnal (log)

Exemple de procese daemon:
  - procesul init
  - procese de tip servicii (Ex. `cron`, pentru servicii de retea)
  - alte procese rulate de user pentru a rula fara un terminal asociat

Caracteristici ale unui proces daemon:
  - ruleaza in bakground fara interactiune directa cu user-ul
  - ofera un serviciu sistemului (planificare, indexare de fisiere etc.)
  - nu are un terminal asociat
  - are ca proces parinte init

Obs. Pentru a afisa in chell o lista aproximativa a proceselor daemon existente, rulam in terminal comada ps -f --ppid 1

## 4.6.4: Detasarea de terminal











