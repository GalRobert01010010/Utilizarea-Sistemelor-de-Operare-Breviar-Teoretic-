# Capitolul 7: Interfata in linia de comanda

Def. Interfata = modul prin care utilizatorul interactioneaza cu o aplicatie sau un sistem.
- unele aplicatii sunt neinteractive
  - Ex. programe batch
  - nu ofera interfata cu utilizatorul
  - ruleaza in bg
- aplicatiile interactive ofera interfata
  - GUI (Grafhical User Interface)
  - CLI (Command Line Interface)
  - web (webUI)
Obs. Interfetele CLI se folosesc pentru a ajunge cel mai rapid la rezultat.
- GUI este mai accesibila
  - e folosita predominant pe medii mobile si in cele mai multe medii desktop
  - elementele GUI sunt WIMP (Window, Icon, Menu, Pointer)
  - pe sistemele mobile se foloseste ecran tactil
- CLI este universala si ofera acces rapid la functionalitatea sistemului
  - mai simpla, eficienta si cu facilitati complexe
  - prezinta un prompt unde user-ul introduce comenzi pentru a interactiona cu sistemul sau aplicatia
  - Ex. Linux shell, PowerShell, python shell, game consoles etc.


## 7.1: Shellul. Functionarea shellului

Def. Shell = aplicatie care realizeaza interactiunea dintre user si sistemul de operare.
- poate fi GUI sau CLI

## 7.1.1: Interactiunea cu shellul

- ofera prompt unde se introduc comenzi
- promptul poate contine informatii suplimentare
  - Ex. numele utilizatorului, numele statiei de lucru, directorul curent

Def. Comanda = un sir de caractere interpretat de shell, odata de user-ul apasa tasta Enter.
=> shellul CLI se mai numeste interpretator de comenzi
- folosim tastatura pt input si ecranul pentru output

Def. Terminal = interfata prin care shellul interactioneaza cu utilizatorul
- descroptorii standard ai shellului refera terminalul (afisarea lor obisnuita se va face pe terminal)
=> terminalul este un canal de comunicare intre shell si user


## 7.1.2: Facilitati shell

- folosirea shellului implica eficcitate si eficienta
- eficacitatea
  - data de comenzile adecvate si parametri corespunzatori
- eficienta
  - data de viteza de tastare a comenzilor (generarea rapida a comenzilor sau editarea raspida a unei comenzi)
  - pt generare rapida, shellul poate completa automat comenzi sau poate cauta in istoricul de comenzi


## 7.1.2.1: Completarea comenzilor

- este o facilitate esentiala a folosirii interfatei in linia de comanda
Tasta Tab
  - permite completarea unei comenzi sau a unui argument fara tastarea acesteia in totalitate
  - daca shellul poate deduce ce comanda vrem sa folosim, la apasarea tastei Tab va completa automat
  - daca sunt mai multe optiuni, la apasarea de doua ori a tastei Tab se vor afisa posibilitatile


## 7.1.2.2: Istoricul de comenzi

Utilitarul `history`
  - afiseaza intreg istoricul de comenzi din sesiunea curenta

- !! : Reexecută ultima comandă introdusă. Este utilă mai ales când ai uitat să pui sudo la început.
- !-n : Reexecută comanda care s-a aflat cu n poziții în urmă în istoric (ex: !-13 execută a 13-a comandă numărată de la coadă la cap).
- !string : Reexecută ultima comandă care începe cu șirul de caractere specificat (ex: !sna va rula ultima comandă snap).
- Ctrl+r : Activează funcția reverse-i-search. Permite căutarea incrementală prin istoricul de comenzi pe măsură ce tastezi caractere din interiorul unei comenzi vechi.

- Exemple practice:
- sudo !! : Execută ultima comandă cu drepturi de administrator (previne reintroducerea manuală a unei comenzi lungi după o eroare de acces).
- !-13 : Execută comanda aflată pe poziția curentă minus 13 în lista history.
- Ctrl+r ink : Va căuta în istoric și va afișa ultima comandă care conține subșirul ink (în exemplul tău, pinky teacher).

Comanda anterioara:
  - sageata sus
  - Ctrl + p

Comanda urmatoare:
  - sageata jos
  - Ctrl + n

Emacs
  - editor de text din ecosistemul Unix / Linux
  - mediu intreg care se bazeaza pe combinatii de taste folosint Ctrl si Meta (de obicei tasta Alt)
  Editarea liniei de comanda:
- Navigarea cursorului:
- Ctrl + a : Mută cursorul la începutul liniei de comandă (Anterior).
- Ctrl + e : Mută cursorul la sfârșitul liniei de comandă (End).
- Alt + f : Mută cursorul înainte cu un cuvânt (Forward).
- Alt + b : Mută cursorul înapoi cu un cuvânt (Backward).

- Ștergerea textului (Cutting/Killing):
- Ctrl + k : Șterge tot textul de la poziția curentă a cursorului până la sfârșitul liniei.
- Ctrl + u : Șterge tot textul de la poziția curentă a cursorului până la începutul liniei.
- Alt + d : Șterge cuvântul de după cursor.
- Ctrl + w : Șterge cuvântul de dinaintea cursorului.

- Recuperarea textului (Pasting/Yanking):
- Ctrl + y : Lipsește (paste) ultimul fragment de text șters/tăiat.

- Altele:
- Ctrl + l : Curăță ecranul (echivalent cu comanda clear), dar păstrează linia curentă intactă.
- Ctrl + _ : (Undone) Anulează ultima modificare făcută în linia de comandă.

Obs. Cautarea inapoi (Reverse Search) si command-line completion sunt esentiale pentru eficienta.


## 7.1.2.3: Editarea comenzilor

- un mod simplesit de editare a unei comenzi se face cu tastele sagetile (stanga si dreapta) in combinatie cu Backspace si Delete
- deplasari mai rapide se fac cu tastele Home si End
  Tasta Home: Mută cursorul la începutul liniei curente.
    Echivalent Emacs (folosit în Bash): Ctrl + a
  Tasta End: Mută cursorul la sfârșitul liniei curente.
    Echivalent Emacs (folosit în Bash): Ctrl + e
Obs. Folosirea de combinatii de taste furnizate de shell au avantaje:
  1) Nu indeparteaza degetele de pe taste comune.
  2) Permite editari mai complexe si raspide ale comenzii
Def. Core Dump = un fișier care conține starea memoriei RAM în momentul prăbușirii.

  - folosite pentru a opri pprocesul curent
    SIGINT (interrupt) - Ctrl + c
      - pentru utilizare normala
      - nu contine Core Dump, dar procesul isi inchide fisierele si lasa mediul curat
      - mod politicos de a opri o comanda care ruleaza in terminal
      - cand comanda se opreste, afiseaza statusul la final
    SIGQUIT (quit) - Ctrl + z
      - nu contine Core Dump, dar procesul isi inchide fisierele si lasa mediul curat
      - mod politicos de a opri o comanda care ruleaza in terminal
      - cand comanda se opreste, afiseaza statusul la final
    SIGQUIT (quit) - Ctrl + \
      - contine Core Dump
      - mai brusc, folosit de obicei cand un program nu mai raspunde corect
      - folosit cand e nevoie de o analiza tehnica
    SIGKILL (kill) - fara combinatie de taste
      - nu contine Core Dump
      - instantaneu, nu poate fi blocat sau ignorat de un proces
      - procesul care primeste acest semnal va fi sters din tabela de procese

- Alt + . : Inserează ultimul argument al comenzii anterioare. Este esențial pentru viteza de lucru în CLI.
  - combinatia de taste Alt+. este folosită pentru cazurile în care una dintre comenzile anterioare contine ca ultim argument o valoare refolosibilă
  - provine din editorul Emacs și elimină necesitatea de a tasta din nou căi lungi sau nume de fișiere.

Exemple în terminal:

Cazul 1: Crearea unui director și accesarea lui
  student@uso:~$ mkdir director_cu_nume_foarte_lung_si_complicat
  student@uso:~$ cd [Alt + .]
  student@uso:~$ cd director_cu_nume_foarte_lung_si_complicat
  
Cazul 2: Verificarea unui fișier și apoi editarea lui
  student@uso:~$ ls /etc/default/keyboard
  student@uso:~$ nano [Alt + .]
  student@uso:~$ nano /etc/default/keyboard
  
Cazul 3: Utilizarea repetată (navigare în istoricul argumentelor)
  -Dacă apeși Alt + . de mai multe ori, shell-ul va aduce ultimele argumente de la comenzile și mai vechi.
  student@uso:~$ cat /etc/passwd
  student@uso:~$ ls /etc/group
  student@uso:~$ echo [Alt + .] -> afișează /etc/group
  student@uso:~$ echo [Alt + .] [Alt + .] -> afișează /etc/passwd


## 7.1.2.4: Biblioteca Readline

- exista combinatii de taste si in in alte interfete in linia de comanda precum Python shell sau MySQL shell sau SQlite shell

Combinatii de taste in shell:
  Ctrl+c - are semnanul SIGINT
         - ternimarea procesului interactiv curent / anularea comenzii tastate in shell
  Ctrl+\ - are semnalul SIGQUIT
         - terminarea fortata procesului interactiv curent (contine Core Dump)
  Ctrl+d - livrarea EOF si inchiderea shellului
  Alt+. - completarea in shell al ultimului argument al ultimei comenzi
  Ctrl+a - plasarea cursorului de editare la inceputul comenzii
  Ctrl+e - plasarea cursorului de editare la sfarsitul comenzii
  Alt+b - plasarea cursorului cu un cuvant inapoi
  Alt+f - plasarea cursorului cu un cuvant inainte
  Ctrl+u - stergerea din pozitia curenta pana la inceputul comenzii
  Ctrl+k - stergerea din pozitia curenta pana la sfarsitul comenzii
  Ctrl+d - stergerea liniei de sub cursor (echivalent Delete)
  Alt+d - stergerea cuvantului din fata cursorului
  Alt+Backspace - stergerea cuvantului din spatele cursorului

Obs. Aceste scurtaturi de tastatura sunt prezente in mai multe shelluri, deoarece majoritatea shellurilor folosesc Readline.


## 7.1.3: Functionarea shellului

- shellul interpreteaza comenzile si argumentele acestora primite de la user
  - acestea se separa prin caracterul " " (spatiu)
- daca sintaxa comenzii este corecta, shellul va efectua comanda
- pentru aceasta, gaseste un fisier executabil aferent comenzii si creeaza un proces in acel fisier
  - Ex. pentru ls
    - fisierul executabil este /bin/ls
  - Ex. pentru sudo
    - fisierul executabil este usr/bin/sudo
Obs. Pentru localizarea unui fisier executabil aferent unei comenzi, shellul foloseste variabila de mediu PATH.


## 7.1.3.1: Variabila de mediu PATH

- contine directoarele in care sunt cautate fisierele executabile pentru o comanda, separate prin ":" (doua puncte)
- daca se transmite o comanda (Ex. ls, cd etc) prin cale (absoluta sau relativa), nu se mai cauta in PATH
Obs. Directorul curent este absent din PATH, de aceea se ruleaza explicit un executabil ./nume_executabil
- o variabila are un nume si o valoare
- pentru a afisa valoarea (continutul):
  Ex. 
    student@uso:~$ echo $USER
    student
    student@uso:~$ echo $PATH
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/
    usr/local/games:/snap/bin

Utilitarul `which`
  - folosit pentru a afla fara a rula, care este fisierul executabil aferent unei comenzi
  - which: Afișează calea absolută a fișierului executabil care ar fi rulat în terminal
    - Exemplu: which ls
  - which -a: (All) Afișează toate locațiile din PATH care conțin executabilul, nu doar pe prima găsită
    - Exemplu: which -a python3
  - which -s: (Silent) Nu afișează nimic; returnează doar un cod de stare (util în scripturi pentru a verifica existența unei comenzi)
    - Exemplu: which -s git && echo "Instalat"

## 7.1.3.2: Crearea unui proces nou

- un proces este creat prin intermediul unui altuia (de exemplu shellul)
- shellul creeaza un proces printr-un API intern al sistemului de operare, care in Linux este dat de doua functii: fork() si exec()
  Def. API (Application Programming Interface) = un set de reguli si de unelte care permit unui program sa comunice cu alt program sau cu OS.

fork()
  - proces care creeaza un proces copil identic cu procesul parinte
exec()
  - apelul care modifica imaginea procesului copil cu cea din executabilul primit ca parametru

Ex. 
  - shellul primeste comanda `ls` si identifica executabilul /bin/ls
  - apoi creeaza un proces copil identic folosind fork()
  - apoi inlocuieste imaginea de executabil cu /bin/ls folosind exec()
- procesul nou creat are ca parinte shellul

 Relația Părinte-Copil în Shell
  - Shell-ul este părintele (PPID) oricărei comenzi lansate din el.
  - echo $$ : Afișează PID-ul shell-ului curent.
  - ps -f -C <nume> : Comandă pentru a vedea PID-ul procesului și PPID-ul (care va coincide cu PID-ul shell-ului).
    Explicatie:
    - ps -f: (Full-format) Afișează o listă detaliată care include coloanele UID, PID, PPID, C, STIME, TTY, TIME și CMD.
      - Exemplu: ps -f
    - ps -C: (Command) Filtrează procesele după numele executabilului.
      - Exemplu: ps -C sleep
    - ps -f -C: Combină afișarea detaliată cu filtrarea după nume.
      - Exemplu: ps -f -C bash

 Comportamentul Shell-ului
  - Blocare: Shell-ul așteaptă implicit finalizarea procesului copil (foreground).
  - Buffer terminal: Datele tastate în timpul execuției sunt stocate și transmise shell-ului abia după deblocare.
  - Background (&) : Operator folosit pentru a lansa procesul fără a bloca shell-ul.

 Codul de ieșire (Exit Code)
  - $? : Variabilă care reține succesul/eșecul ultimei comenzi.
  - 0 : Succes.
  - != 0 : Eroare.

- Exemple în terminal:

# Pas 1: Aflăm PID shell
student@uso:~$ echo $$
14599

# Pas 2: Lansăm proces și verificăm ierarhia din alt terminal
student@uso:~$ sleep 100
# (În alt terminal)
student@uso:~$ ps -f -C sleep
# Rezultat: PID 14619, PPID 14599

# Pas 3: Verificăm codul de ieșire
student@uso:~$ ls /neexistent
student@uso:~$ echo $?
# Rezultat: o valoare diferită de 0 (eroare)


## 7.1.4: Comenzi interne si comenzi externe

- cand rulam o comanda, shellul identifica un fisier executabil aferent acelei comenzi
Def. Comenzi externe = comenzi al caror executabil este separat de shell.
- din ratiuni de viteza si de functionalitate, unele comenzi sunt implementate la nivelul shellului
Def. Comenzi interne = comenzi care duc la rularea unei componente de program din procesul shell curent
  - acestea nu mai creeaza un proces nou dintr-un executabil

- comenzile interne sunt folosite din ratiuni de eficienta
- crearea unui proces nou inseamna cost de timp (overhead) la nivelul shellului

Obs. Comenzile externe sunt prevalente pentru moduilaritate.
  - comenzile noi se adauga prin adaugarea unui nou executabil, fara a modifica shellul

- comanda `which`
  - ne spune tipul unei comenzi si precizeaza tipul de executabil asociat
  - binar independent
- comanda `type`
  - varianta mai robusta decat `which`
  - comanda integrata


## 7.2: Functionalitati shell

- shellul oermite rularea de comenzi cu sau fara parametri
- shellul are functionalitati care permit inlantuirea si combinarea mai multor comenzi si configurarea modului in care opereaza
  - functionalutatile sunt oferite de: variabile, operatori, expandari, constructii agregate


## 7.2.1: Operatori shell

- cei mai frecvent folositi sunt cei de redirectare si inlantuire
  - redirectare: >, <, >>, 2>      (sectiunea 2.4)
  - inlantuire: ;, ||, &&, |       (sectiunea 4.5.3)
Obs. Folosim "&" pentru rularea unui proces in background. (sectiunea 4.3.3)


## 7.2.2: Subshelluri

Ex.
  student@uso:~$ ls ; ps > a.out
  Desktop Documents Downloads examples.desktop Music
  snap Templates uso.git Videos vm-actions-log.txt  Pictures Public
  student@uso:~$ ( ls ; ps ) > a.out
Diferenta: 
  - in prima comanda doar rezultatul `ps` este redirectat
  - in a doua, se creeaza un subshell pentru a inlantui comenzi
    Def. Subshellul este un proces nou shell care suleaza cele doua comenzi si le transmite outputul


## 7.2.3: Variabile shell

- pot fi folosite pentru a investiga si configura executia shellului
- variabila are nume si valoare
- pt a afisa numele variabile, o prefixam cu "$"

Parametri din shell asemuiti unor variabile:
  $ - PID-ul procesului shell curent
  ! - PID-ul celui mai recent proces din background
  ? - codul de iesire al celei mai recente comenzi
  _ - ultimul argument al celei mai recente comenzi

Parametrii speciali pentru shell scripting (sectiunea 13.3.1):
  # - numărul de parametri primiți de script (echivalent argc din C)
  0 - numele scriptului curent (echivalent argv[0] din C)
  1, 2, ... - primul, al doilea, etc. parametru primit de script
  * - toți parametrii scriptului tratați ca un singur șir de caractere
  @ - toți parametrii scriptului tratați ca elemente individuale

Variabile predefinite Bash:
  PATH - caile de cautare a fisierelor executabile pentru comenzi
  PWD - directorul curent
  USER - numele utilizatorului curent
  HOME - directorul home al utilizatorului curent
  SHELL - shellul curent
  TERM - tipul de terminal folosit

Obs. Pentru a vedea toate variabilele predefinite intr-un shell Bash, folosim `declare`.
Obs. Pentru a anula definirea unei variabile, folosim `unset`.


## 7.2.3.1: Variabile de mediu

Def. Variabila de mediu = = variabila modtenita de procesele din shell.
Obs. Marcam o variabila ca variabila de mediu cand vream sa fie mostenita si vizibila in alt proces.

Diferența de Scop - Shell vs. Environment
  - Variabilă simplă: Este vizibilă exclusiv în procesul Bash curent. Niciun program pornit din acest terminal nu o poate accesa.
    Exemplu: USER_NOTE="Sunt in terminal"
  - Variabilă de mediu: Este copiată în memoria oricărui proces nou creat din acest shell. Este metoda standard de configurare a programelor.
    Exemplu: export EDITOR=nano

Utilitarul `env` - Environment
  - Afișează toate variabilele de mediu exportate în sesiunea curentă a shell-ului.
    Exemplu: env
  - env -i: Ignoră mediul moștenit și pornește un proces nou într-un mediu complet gol.
    Exemplu: env -i /bin/sh
  - env VAR=VALOARE: Rulează un program cu o variabilă de mediu specifică, fără a o modifica pe cea din shell-ul părinte.
    Exemplu: env LANG=fr_FR.UTF-8 vlc
  - env -u: Șterge (unset) o variabilă specifică din mediul în care rulează comanda.
    Exemplu: env -u HOME bash

Utilitarul `export` - Export Variables
  - Marchează o variabilă shell pentru a fi moștenită de toate procesele copil create ulterior.
    Exemplu: export NUME_VAR=valoare
  - export -p: Afișează toate variabilele exportate în shell-ul curent sub forma unor comenzi "declare -x".
    Exemplu: export -p
  - export -n: Elimină atributul de "export" al unei variabile; aceasta rămâne o variabilă de shell.
    Exemplu: export -n LANG
  - export -f: Exportă o funcție definită în shell către procesele copil.
    Exemplu: export -f numele_functiei

Obs. Pentru a vedea toate variabilele de mediu definite, folosim comanda `export -p` sau `env`.
Obs. Folosim `export` pentru a defini o variabila de mediu.
Obs. Folosim `export -n` pentru ca o variabila sa nu mai fie definita ca variabila de mediu. 

Utilitarul `declare` - Shell Variable Management
  - Afișează toate variabilele (locale și de mediu) și funcțiile definite în sesiunea curentă a shell-ului.
    Exemplu: declare
  - declare -x: Marchează o variabilă pentru export, transformând-o în variabilă de mediu (identic cu comanda export).
    Exemplu: declare -x CONFIG_PATH=/etc/settings
  - declare -r: Definește o variabilă "read-only", a cărei valoare nu mai poate fi modificată sau ștearsă.
    Exemplu: declare -r ID_SISTEM=99
  - declare -i: Forțează variabila să fie tratată ca un întreg, permițând calcule matematice directe.
    Exemplu: declare -i CALCUL=10+5
  - declare -p: Afișează atributele și valoarea unei variabile specifice sub formă de comandă.
    Exemplu: declare -p PATH

Folosirea variabileor temporare:
  - implica faptul ca nu e nevoie sa declaram mereu variabile de mediu cand rulam procese

  Injectarea Variabilelor per Proces (Inline Definition)
  - Permite definirea unei variabile care va fi moștenită ca variabilă de mediu doar de către programul lansat, fără a afecta shell-ul curent.
    Exemplu: TR_DEBUG=1 transmission-cli
  - Variabila încetează să existe imediat ce procesul respectiv se închide și nu apare în comanda `env`.
    Exemplu: LANG=en_US.UTF-8 vlc
> Obs. `transmission-cli` este varianta de terminal (CLI) a unui client de descărcat fișiere
  - este folosit în exemple pentru a demonstra cum variabilele de mediu pot activa funcții ascunse (precum depanarea/debug) dintr-o singură comandă.


## 7.2.4: Expandari

- comenzile de intrare din shell pot cuprinde parametri, operatori si variabile

Variabile de Mediu Esențiale
  - HOME: Reține calea către directorul personal al utilizatorului.
    Exemplu comandă: echo $HOME
    Exemplu afișare: /home/student
  - PATH: Listă de directoare unde shell-ul caută executabilele comenzilor introduse.
    Exemplu comandă: echo $PATH
    Exemplu afișare: /usr/local/bin:/usr/bin:/bin
  - TERM: Specifică tipul de terminal utilizat pentru a știi cum să afișeze culorile sau caracterele speciale.
    Exemplu comandă: echo $TERM
    Exemplu afișare: xterm-256color

Expandarea cu tildă (Liniile 1-2)
  - Înlocuiește `~` cu valoarea variabilei $HOME.
    Exemplu comandă: ls ~/Downloads/
    Exemplu afișare: idafree70_linux.run opensc-0.20.0

Expandarea cu acolade (Liniile 4-12)
  - Multiplică argumentele prin enumerarea opțiunilor, utilă pentru a accesa mai multe resurse deodată.
    Exemplu comandă: ls lab{02,03}
    Exemplu afișare: lab02: anul_1 demo  lab03: pc project

Expandarea parametrică / a variabilelor (Liniile 14-19)
  - Înlocuiește numele variabilei cu valoarea ei.
    Exemplu comandă: echo $config
    Exemplu afișare: /etc/nsswitch.conf
  - Concluzie delimitare: Acoladele `${}` sunt necesare pentru a fixa numele variabilei atunci când aceasta este lipită de alte caractere (litere, cifre, underscore).
    Exemplu comandă: echo ${config}_test
    Exemplu afișare: /etc/nsswitch.conf_test

Expandarea aritmetică (Liniile 21-24)
  - Permite efectuarea calculelor matematice prin construcția `$(( ))`.
    Exemplu comandă: echo $((3+4))
    Exemplu afișare: 7


## 7.2.4.1 Globbing

- se mai numeste "expandarea căilor" (pathname expansion)
- se refera la constructii specifice shellului care pot fi expandate la a se potrivi cu mai multe optiuni

Expandarea Parametrică Avansată (Manipularea String-urilor)

  - Afișarea valorii (Delimitare): Folosită pentru a izola numele variabilei.
    Comandă: echo ${config}
    Funcționalitate: Afișează conținutul curat al variabilei.
    Rezultat: /etc/nsswitch.conf

  - Lungimea șirului (${#var}): Returnează numărul de caractere din variabilă.
    Comandă: echo ${#config}
    Funcționalitate: Numără tot (litere, cifre, semne de punctuație).
    Rezultat: 18

  - Înlocuirea de text (${var/vechi/nou}): Caută un subșir și îl înlocuiește.
    Comandă: echo ${config/ns/df}
    Funcționalitate: Înlocuiește prima apariție a șirului "ns" cu "df".
    Rezultat: /etc/dfswitch.conf

  - Înlocuirea multiplă (${var//vechi/nou}): Caută și înlocuiește TOATE aparițiile subșirului.
      Comandă: echo ${config//n/X}
      Funcționalitate: Înlocuiește fiecare literă "n" din variabilă cu litera "X".
      Rezultat: /etc/Xsswitch.coXf

  - Ștergere de la început (${var#model}): Taie cel mai scurt segment care se potrivește cu modelul, pornind de la stânga.
    Comandă: echo ${config#/*/}
    Funcționalitate: Șterge tot ce se află între primele două caractere "/" (inclusiv acestea).
    Rezultat: nsswitch.conf

  - Ștergere de la sfârșit (${var%model}): Taie segmentul care se potrivește cu modelul, pornind de la dreapta.
    Comandă: echo ${config%/*}
    Funcționalitate: Șterge tot ce urmează după ultimul "/" (inclusiv slash-ul), lăsând doar calea directorului.
    Rezultat: /etc

Tehnici de Globbing (Potrivirea numelor de fișiere)

  - Caracterul `*` (Wildcard universal): Se potrivește cu orice șir de caractere (inclusiv niciunul).
    Comandă: ls *.c
    Funcționalitate: Afișează toate fișierele care se termină în ".c".
    Rezultat: main.c helper.c tema.c

  - Caracterul `?` (Single character): Se potrivește cu un singur caracter, exact unul.
    Comandă: ls tema?.c
    Funcționalitate: Caută fișiere ca tema1.c, tema2.c, dar NU tema10.c (două caractere).
    Rezultat: tema1.c temaA.c

  - Setul `[...]` (Character set): Se potrivește cu oricare dintre caracterele din interior.
    Comandă: ls lab[123].txt
    Funcționalitate: Caută doar lab1.txt, lab2.txt sau lab3.txt.
    Rezultat: lab1.txt lab3.txt

  - Intervalul `[a-z]` (Range): Se potrivește cu orice caracter dintr-un interval definit.
    Comandă: ls [a-c]*.txt
    Funcționalitate: Afișează fișierele care încep cu litera a, b sau c și se termină în .txt.
    Rezultat: ana.txt bogdan.txt costel.txt

Tehnici Avansate de Globbing

  - Negarea setului ([!...]): Selectează orice caracter care NU se află în lista specificată. 
    Este opusul setului clasic.
    Comandă: ls lab[!0-9].txt
    Funcționalitate: Afișează fișierele care au un caracter non-numeric după cuvântul "lab".
    Rezultat: labA.txt, lab_backup.txt (Ignoră lab1.txt sau lab2.txt).

  - Globbing Recursiv (**): Caută în folderul curent și în TOATE subdirectoarele de orice adâncime.
    Comandă: ls **/solutie.c
    Funcționalitate: Găsește orice fișier "solutie.c" indiferent cât de adânc e ascuns în structura de foldere.
    Rezultat: solutie.c, runda1/problema1/solutie.c, arhiva/vechi/solutie.c.
    Notă: Necesită activarea cu `shopt -s globstar`.

  - Seturi de clase predefinite ([[:clasa:]]): Folosește categorii de caractere standardizate (Portable Operating System Interface).
    Comandă: ls *[[:digit:]]*
    Funcționalitate: Găsește orice fișier care conține cel puțin o cifră în nume.
    Rezultat: tema1.c, varianta_02.txt.
    Alte clase utile: [:alpha:] (litere), [:upper:] (majuscule), [:space:] (spații).
      De ce adăugăm "*" in constructia "ls *[[:digit:]]*"?
        - dacă scrii doar ls [[:digit:]], shell-ul va căuta fișiere al căror nume este format dintr-o singură cifră (de exemplu, fișierul 5).

















