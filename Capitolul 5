# Capitolul 5: Utilizatori

- utilizatorii creeaza procese (aplicatii) care folosesc resursele sistemului (Ex. procesor, memorie, I/O etc.)
- utilizatorii transfera date in SAU din sistemul de calcul folosind sistemul de fisiere sau reteaua
- utilizatorii au acces la resursele sistemului de calcul printr-un cont de user care are niste permisiuni
- pe un sistem de operare modern pot exista mai multi utilizatori, ale caror procese ruleaza separat (izolat)
- un cont de utilizator e reprezentat de username

## 5.1: Utilizatori de sistem

- sunt folosite pentru a obtine acces la resursele gestionate de sistemul de operare
- conturile de utilizator permit obtinerea unui shell si rularea de comenzi care creează procese
- in momentul autentificării unui utilizator de sistem, acesta are acces complet la o partedin sistemul de fisiere 
    - acest sistem de fisiere se numeste directorul home al utilizatorului, reprezentand directorul personal al acestuia
    - Ex. /home/student pe Linux, C:\user\student pe Windows si /Users/student pe macOS

## 5.1.1 Permisiuni si privilegii

- din punct de vedere al conceptelor de securitate:
  - utilizatorul e un agent
  - resursele puse la dispozitie sunt obiecte
Def. Politica de securitate (security policy) a sistemului precizează permisiunile si dictează ce agenti au acces la ce obiecte.
- definitia politicii de securitate da nastere termenilor permisiune si privilegiu
Def. Permisiunile = informatii aferente obiectului care stabilesc ce agenti pot face tipuri de actiuni.
Def. Privilegiile = certificate aferente agentului care stabilesc ce actiuni poate acesta întreprinde.
- in sistemele de operare de uz general (Linux, Windows, macOS), exista utilizatori obisnuiti (neprivilegiati) si utilizatori privilegiati
Def. Utilizatorii neprivilegiati au acces complet la o parte din sistemul de fisiere (directorul home) si pot crea procese care folosesc aceste resurse.
Def. Utilizatorii privilegiati pot face actiuni care afectează starea globală a sistemului: 
  - Ex. instalare de pachete, adăugare si stergere de utilizatori, repornirea sistemului, configurarea datei sistemului, 
        schimbarea permisiunilor sistemului, configurarea retelei etc.
Def. Superuser = utilizator cu permisiuni depline.
  - pe Linux / Unix se numeste root
  - pe Windows se numeste Administrator

## 5.2: Utilizatorul administrativ (superuser)

## 5.2: Utilizatorul administrativ (superuser)

- utilizatorul administrativ, superuserul, detine controlul complet al sistemului
- toate operatiile privilegiate, inaccesibile unui utilizator obisnuit neprivilegiat, sunt permise acestuia
- un utilizator obisnuit va accesa acest cont special pentru a realiza o operatie privilegiata
    - accesul se face daca utilizatorul stie parola sau forma de autentificare a acestuia
- faptul ca superuserul are acces complet la sistem il face foarte periculos de folosit
- daca un atacator obtine acces neautorizat la contul de superuser, atunci sistemul este compromis
- daca rulam gresit o comanda privilegiata, aceasta poate afecta iremediabil sistemul
- Ex. rm -fr /: comanda este celebra pentru ca poate fi folosita pentru a sterge tot sistemul de fisiere
    - daca este folosita de contul de root, aceasta comanda sterge continutul sistemului de fisiere incepand de la radacina (/)
- recomandari de folosire pentru superuser:
    - sa fie folosit contul doar cand este absoluta nevoie, pentru operatii privilegiate
    - nu va autentificati ca superuser pe interfata grafica
    - sa fie o parola sau forma de autentificare cat mai greu de accesat in mod neautorizat
    - sa fie evitata folosirea superuser-ului cand exista forme alternative de executare de actiuni privilegiate
- sistemele de operare moderne ofera optiuni alternative:
    - In Linux/Unix: sudo, bitul setuid, capabilitati (prezentate in Sectiunea 5.2.3)
    - In Windows: User Account Control (UAC)
        - Def. User Account Control = tehnologie care ofera un prompt care trebuie confirmat ori de cate ori se doreste realizarea unei actiuni privilegiate

## 5.2.1: Utilizatorul administrativ in Linux (root)

- utilizatorul administrativ in Linux este numit root
- utilizatorul root are acces complet la resursele sistemului si poate face orice operatii
- accesarea contului de root este evidentiata in linia de comanda prin simbolul # (diez) la finalul promptului
- Ex. Listing 5.1:
    student@uso:~$ sudo su
    [sudo] password for student:
    root@uso:/home/student#
- in secventa de mai sus:
    - utilizatorul initial este student, iar promptul sau are simbolul $ (dolar)
    - dupa folosirea sudo su si introducerea parolei, se obtine un shell privilegiat cu simbolul #
- accesarea unui cont se poate face in doua moduri:
    - autentificarea in sistem (la login in linia de comanda sau interfata grafica)
    - schimbarea utilizatorului curent in linia de comanda prin folosirea comenzii su (substitute user)
- nu este recomandata autentificarea direct in sistem folosind contul de root
    - orice aplicatie lansata din acest cont va avea acces complet, devenind o posibila zona de atac
- este recomandat sa folositi comanda su pentru schimbarea temporara a utilizatorului si apoi revenirea cu exit
- Ex. Listing 5.2:
    student@uso:~$ su
    Password:
    root@uso:/home/student# apt install deluge
    root@uso:/home/student# exit
    student@uso:~$

## 5.2.2: Utilitarul su

- utilitarul su este folosit pentru schimbarea utilizatorului, nu neaparat in root
- daca su nu primeste niciun argument sau primeste root, va schimba utilizatorul in root
- la rularea comenzii se cere parola noului utilizator (utilizatorul destinatie)
- Ex. Listing 5.3:
    student@uso:~$ su teacher
    Password:
    teacher@uso:/home/student$ exit
- diferenta intre su si su - (sau su -l):
    - su [user]: schimba doar identitatea, dar pastreaza directorul curent si variabilele de mediu ale vechiului utilizator
    - su - [user]: schimba identitatea si incarca complet mediul de lucru al noului utilizator (Login Shell)
    - se observa in prompt: la su - locatia se schimba automat in directorul home al noului user (simbolul ~)
- diferenta intre comenzile de iesire exit si logout:
    - exit: este comanda universala care inchide orice shell curent si te intoarce la utilizatorul anterior
    - logout: functioneaza doar daca shell-ul curent este un Login Shell (creat prin su - sau su -l)
    - Ex. in Listing 5.3:
        - la linia 3 s-a folosit exit deoarece su simplu nu creeaza un login shell
        - la liniile 6 si 9 s-a folosit logout deoarece su -l a creat o sesiune de login completa
- utilitarul su permite rularea unei comenzi fara a deschide un shell prin optiunea -c
    - se ruleaza direct comanda primita ca argument si apoi se revine automat la shell-ul initial
    - Ex. Listing 5.3 (punctul 10):
        student@uso:~$ su -l teacher -c whoami
        Password:
        teacher
    - dupa afisarea rezultatului (teacher), sesiunea se inchide singura fara a mai fi nevoie de exit sau logout

## 5.2.3: Alternative la root in Linux

- root detine controlul intregului sistem
- sistemele de operare moderne ofera optiuni de granularizare a privilegiilor
    - Ex. bitul setuid, capabilitati si utilitarul sudo
Bitul setuid (set-user-id-on-execution):
    - bit asociat unui fisier executabil
    - cand se executa fisierul, procesul nou creat nu va apartine celui care l-a executat, ci va apartine celui care a creat fisierul (de obicei root)
    - Ex. student@uso:~$ ls -l /bin/ping
          2 -rwsr-xr-x 1 root root 64424 Mar 10 2017 /bin/ping
          3 student@uso:~$ ls -l /bin/su
          4 -rwsr-xr-x 1 root root 44664 Jan 25 2018 /bin/su
          5 student@uso:~$ ls -l /usr/bin/sudo
          6 -rwsr-xr-x 1 root root 149080 Jan 31 2020 /usr/bin/sudo
    - in permisiunile fisierelor se observa litera "s" (bitul setuid)
    Obs. Prezenta bitului setuid pe un executabil detinut de root (de exemplu passwd, su, sudo) -> acele comenzi pot fi rulate de orice utilizator pentru a crea procese privilegiate
    - dezavantajul este ca procesul nou creat ruleaza cu privilegii complete de root
Capabilitatile:
    - mecanism in Linux
    - concept de baza in sistemele de operare
        - presupune atasarea unui privilegiu unui agent (obiect)
    - Ex. Executabilul aferent utilitarului ping are atasata capabilitatea cap_net_raw.
        - aceasta capabilitate înseamna ca procesele create din executabilul ping vor avea privilegiul de a crea resurse privilegiate necesare utilitarului ping
    Obs. Spre deosebire de bitul setuid, capabilitatile sunt granulare. 
        - un proces are atasate doar capabilitatile de care are nevoie.
    Exemple:
        - cap_net_raw: permite folosirea de socketi speciali (numiti raw)
        - cap_net_admin: permite configurarea retelei
        - cap_fowner: permite configurare de permisiuni pe orice fisier
        - cap_kill: permite transmiterea de semnale pe orice fisiere
    Def. Suportul de capabilitati = o componenta avansata a sistemului de operare, care permite dezvoltatorilor de aplicatii configurarea de privilegii granulare.

## 5.2.3.1 Utilitarul sudo

- bitul setuid si capabilitatile nu permit usor atasarea de privilegii utilizatorilor, sau configurarea personalizata (custom) a actiunilor care pot fi executate de acel user.
- pentru asta, solutia pe Linux este utilitar sudo
Def. sudo = utilitar care permite rularea unor comenzi in numele altui utilizator (in general root)
    - are o configurare granulara
    - permite precizarea explicita a ce comenzi sa fie rulate
Obs. Spre deosebire de utilitarul su, sudo nu necesita parola noului utilizator, ci parola utilizatorului curent.
- cand rulam sudo il succedem cu comanda pe care vrem sa o rulam ca root
- sudo permite unui user sa ruleze comensi ca un alt user printr-o configuratie din sistemul de configurare /etc/sudousers
- permisiunile de sudo (adica posibilitatea de a rula comenzi ca root) trebuie acordate cu grija utilizatorilor
- pentru a preveni editarea eronata a fisierului /etc/sudousers, folosim editorul visudo
    - folosim comanda visudo ca root SAU comanda sudo visudo

## 5.2.3.1.1: sudo si redirectare

- consideram urmatoarea situatie: redirectionam rezultatul rularii unei comenzi intr-un fisier privilegiat
- daca dorim sa activam rutarea pe un sistem Linux, rulam, ca root, comanda:
    - student@uso:~$ echo 1 > /proc/sys/net/ipv4/ip_forward
    Def. Activarea rutarii = transformarea dispozitivului de calcul in ruter
        - activarea rutării permite sistemului să primească pachete pe o interfață de rețea și să le trimită mai departe către destinația lor finală prin altă interfață.
        rolul valorilor 1 si 0 in fisierele de configurare:
        - rolul valorilor 1 si 0 in fisierele de configurare:
        - cifra 1 (sau orice valoare diferita de 0) = Activat (On / True)
        - cifra 0 = Dezactivat (Off / False)
        - importanta acestui mecanism:
            - in Linux, configurarea kernel-ului se face prin scrierea acestor valori in fisiere virtuale (totul este un fisier)
            - modificarea valorii in /proc schimba comportamentul sistemului instantaneu, fara a necesita restartarea serviciilor sau a calculatorului
    - Problema redirectarii cu sudo:
        - Comanda: student@uso:~$ sudo echo 1 > /proc/sys/net/ipv4/ip_forward
        - Rezultat: eroare 
            - desi "echo 1" ruleaza ca root prin sudo, redirectionarea (operatorul >) este gestionata de shell
            - shell-ul utilizatorului "student" nu are privilegii sa deschida fisierul de sistem pentru scriere
            - redirectionarea are loc PENTRU comanda sudo, nu IN INTERIORUL ei
Utilitarul tee:
- Def. tee = utilitar care citeste de la intrarea standard (stdin) si scrie simultan la iesirea standard (stdout) SI intr-unul sau mai multe fisiere.
- Ex. student@uso:~$ echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
    - echo 1:
        - ruleaza ca utilizator normal (student)
        - trimite cifra 1 catre conducta (pipe)
    - | (Pipe):
        - transporta datele de la echo catre tee
        - ATENTIE: Pipe-ul nu are nevoie de permisiuni pe fisierul de destinatie, deci nu blocheaza comanda
    - sudo tee [cale_fisier]:
        - utilitarul tee este lansat cu privilegii de ROOT
        - primeste cifra 1 prin pipe
        - fiind root, tee are dreptul sa deschida fisierul privilegiat si sa scrie in el
        - rezolva problema de "Permission denied" a redirectionarii simple
            Optiunea critica: -a (append)
            - implicit, tee suprascrie continutul fisierului (ca operatorul >)
            - tee -a: adauga informatia la sfarsitul fisierului (ca operatorul >>)
            - Ex. student@uso:~$ echo "text nou" | sudo tee -a /etc/hosts

## 5.3: Operații cu utilizatori

- in OS, un utilizator e reprezentat de procesele si resursele acestuia
- la nivelul OS, un user e identificat de un numar, numit user identifier (UID), asa cum un proces e identificat printr-un process identifier (PID)
- procesele si fisierele unui utilizator au în atributele acestora câmpul UID
    - pentru procese, acest câmp ofera informatii despre ce operatii asupra resurselor sistemului de operare pot fi executate de proces
        => procese: UID -> posibile operatii asupra resurselor OS
    - câmpul UID al fisierelor identifica utilizatorul care le detine
        => fisiere: UID -> identifica userul proprietar
Obs. Comanda ps (process status) afiseaza UID proceselor.
    Steaguri pentru ps:
        - ps -l (long format)
        - ps -e (everything): listeaza toate procesele
        - ps -u (user format)
        - ps -a (all without session leaders)
        - ps -f (full-listing)
        - ps -x : procese care ruleaza in background fara terminal
    - nu listeaza procesele care s-au terminat, ci doar cele care inca ruleaza
    - este utilizată pentru a afișa informații despre procesele care rulează în sistem
    - ps -o (output): permite sccesarea unui format personalizat de afisare (în loc să afișeze coloanele implicite, ps va afișa doar coloanele specificate imediat după acest steag)
        - PPID (Parent Process ID): indică sistemului de operare cine este părintele procesului curent
    - Ex. student@uso:~$ ps -o pid,ppid,uid,user,cmd
          PID PPID UID USER CMD
          24104 24103 1000 student -bash
          24610 24104 1000 student ps -o pid,ppid,uid,user,cmd
        - "-bash" este interpretorul de comenzi. Faptul ca am pus "-" in fata indica un Login Shell
        Obs.  PPID-ul lui ps (24104) este exact PID-ul lui bash.
Obs. Comanda stat listeaza UID-ul unui fisier.
    - Ex. student@uso:~$ stat vm-actions-log.txt
          File: vm-actions-log.txt
          Size: 4827 Blocks: 16 IO Block: 4096 regular file
          Device: 801h/2049d Inode: 659107 Links: 1
          Access: (0644/-rw-r--r--) Uid: ( 1000/ student) Gid: ( 1000/ student)
          Access: 2020-08-08 16:32:44.086193999 +0300
          Modify: 2018-08-21 14:37:44.316527432 +0300
          Change: 2018-08-21 14:37:44.320529432 +0300
          Birth: -

## 5.3.1: Atribute ale utilizatorilor. Informatii despre utilizatori

- utilitarul id: afișează UID, GID și grupurile din care face parte utilizatorul
    - Ex. student@uso:~$ id student
    - output-ul va arăta: uid=1000(student) gid=1000(student) groups=1000(student),27(sudo)...
- cele mai importante doua atribute ale unui user sunt: userneme-ul si user identifier (UID)
- ierarhia numerotării UID:
    - UID 0: este rezervat întotdeauna pentru utilizatorul root
    - UID 1 - 999: rezervate pentru conturi de sistem (servicii)
    - UID 1000+: alocate utilizatorilor obișnuiți
- pe sistemele Unix, un user are asociat un login shell
Def. Login shell = programul rulat in momentul autentificarii user-ului pe sistem (apare sub forma unui shell in linia de comanda).
- utilizatorii sunt grupati -> gestiune mai flexibila a accesului la resurse
    - un user poate face parte din unul sau mai multe grupuri
    - un grup poate contine 0 sau mai multi utilizatori
    - un user poate apartine unui sau mai multor grupuri
    - group identifier (GID): identificatorul grupului principal al utilizatorului
- în Linux, există două utilitare pentru crearea conturilor: `useradd` și `adduser`
- diferența între cele două:
    - useradd: utilitar de nivel scăzut (low-level), nu este interactiv
        - acesta creează utilizatorul, dar NU creează automat directorul home sau parola decât dacă sunt specificați parametri suplimentari
    - adduser: script de nivel înalt (high-level), interactiv
        - este recomandat pentru utilizatori deoarece creează automat directorul home, copiază fișierele de bază și solicită parola
- Ex. student@uso:~$ sudo adduser teacher
- procesul de adăugare implică mai mulți pași automați:
    - se adaugă o linie în fișierul `/etc/passwd`
    - se adaugă o linie în fișierul `/etc/shadow`
    - se creează un grup primar cu același nume în `/etc/group`
    - se creează directorul home la calea `/home/nume_utilizator`
    - se copiază fișierele de configurare inițiale (șabloane) din `/etc/skel`



## 5.3.2: Obtinerea de informatii despre utilizatori

- informatii despre user: nume, UID, home director
- pot fi obtinute prin: interfatele grafice aferente unui OS, distributii, utilitare in command line

## 5.3.2.1: Obtinerea de informatii despre useri in Linux

- in Linux, info despre userisunt stocate in fisiere de configurare dedicate
- in scenarii de administrare mai complexe, aceste informatii sunt pastrate intr-o baza de date 
   Fisier                         Rol                                       Informatii
/etc/passwd             informatii utilizatori            username, UID, home directory, GID, login shell
/etc/shadow               parole utilizatori            username, parola criptata, informatii expirare parola
/etc/group                informatii grupuri                    nume grup, GID, utilizatori aferenti

Obs. /etc/passwd este lizibil pentru orice user din sistem.
Obs. /etc/shadow necesita acces root pentru a fi citit.

Utilitae pe care le putem folosi pentru a obtine informatii despre utilizatori:
1)  id
    Rol: info despre user
    Fisierele investigate: /etc/passwd, /etc/group
2)  groups
    Rol: grupurile utilizatorului curent
    Fisierele investigate: /etc/group
3)  users, w, who
    Rol: useri autentificati in sistem acum 
    Fisierele investigate: /var/run/utmp
4)  whoami
    Rol: numele userului curent
    Fisierele investigate: N/A
5)  finger, pinky
    Rol: informatii complete despre un utilizator
    Fisierele investigate: /etc/passwd, /etc/group

Obs. Exista utilizatori care au configurat ca shell de login /bin/false SAU /bin/nologin.
    - acesti utilizatori nu se pot autentifica în sistem si nu pot obtine un shell de login
Def. Utilizatorii de sistem = cei care pot avea procese dar nu pot obtine shell de login.
Def. Utilizatorii interactivi = cei care pot obtine shell si pot rula apoi comenzi.

## 5.3.3: Gestiunea utilizatorilor si a grupurilor

- consta in crearea, stergerea si modificarea user-ilor si a grupurilor
- poate fi facuta doar de un user privilegiat

Operatiile de gestiune a utilizatorilor sunt:
    - crearea unui user
        - un nou cont, identificat prin nume si UID
    - stergerea unui user
        - dupa ce un cont e sters, nu mai pot fi create procese cu acel cont
    - crearea unui grup
    - stergerea unui grup
    - adaugarea unui user la un grup
    - stergerea unui user dintr-un grup
    - schimbarea parolei unui user
    - modificarea atributelor unui user: username, login shell, home directory

## 5.3.3.1: Gestiunea utilizatorilor si grupurilor in Windows

- o facem cu interfata din panoul de control
- exista si utilitare in command line, folosind interfata netsh

## 5.3.3.2: Gestiunea utilizatorilor si grupurilor în Linux

- in Linux, exista interfete grafice pentru gestiunea utilizatorilor in functie de mediul desktop folosit
    - Ex. de medii desktop: GNOME, KDE, XFCE etc.

Utilitare specifice pentru gestiunea in command line:
1)  useradd
    Rol: adaugare utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
2)  userdel
    Rol: sterge utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
3)  usermod
    Rol: modificare utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
4)  groupadd
    Rol: adaugare grup
    Fisierele modificate: /etc/group
5)  groupdel
    Rol: stergere grup
    Fisierele modificate: /etc/group
6)  groupmod
    Rol: modificare grup
    Fisierele modificate: /etc/group
7)  chsh
    Rol: modificare shell
    Fisierele modificate: /etc/passwd
8)  chfn
    Rol: modificare informatii utilizator
    Fisierele modificate: /etc/passwd
9)  passwd
    Rol: schimbare parola
    Fisierele modificate: /etc/shadow

- pe distributiile bazate pe Debian (Debian, Ubuntu, Linux Mint etc.), exista un set de utilitare mai usor de folosit care înglobeaza comenzile de mai sus

Diferenta dintre Utilitare de baza si Utilitar Wrapper:
    - utilitarele de baza: mai rapide si native sistemului
        - acestea sunt: useradd, userdel, groupadd, groupdel
    - utilitarele wrapper: mai interactive (recomandate pentru utilizare manuala)
        - acestea sunt: adduser, deluser, addgroup, delgroup
        - pentru Debian: chsh (schimbare shell de login), chfn (schimbare informatii), passwd (schimbare parola)

- in Linux / Unix exista doua tipuri de grupuri: primare si secundare
- un user apartine unui singur grup primar, si oricator grupuri secundare
Obs. Un grup, care este grup primar al unui user, nu poate fi sters
    - intai trebuie sters userul, apoi grupul

Modificarea și ștergerea utilizatorilor:
- usermod: utilitar folosit pentru a schimba proprietățile unui cont
    - Ex. `sudo usermod -s /bin/zsh student` (schimbă shell-ul implicit în zsh)
    - Ex. `sudo usermod -L student` (blochează contul - Lock)
- deluser / userdel: utilitare pentru ștergerea conturilor
    - implicit, aceste comenzi șterg doar contul, nu și fișierele utilizatorului
    - pentru a șterge și directorul home, se folosește opțiunea `--remove-home`
    - Ex. student@uso:~$ `sudo deluser --remove-home teacher`

## 5.4: Autentificare. Gestiunea parolelor

Def. Autentificare = procedura prin care un utilizator doreste acces la sistemul de operare.
- presupune fornizarea unui username si unei parole
- autentificarea e valabila si pentru aplicatii
  - Ex. aplicatii web, jocuri, aplicatii de baza de date, conturi bancare etc. 
- moduri de autentificare: folosirea de informatii biometrice, dispozitiv de tip token de autentificare, autentificare cu cheie publica
Def. Dispozitiv de tip token de autentificare = dispozitiv hardware sau aplicatie software care genereaza un cod numeric temporar (OTP - One Time Password)
     sau trimite o confirmare criptografica pentru a dovedi identitatea user-ului.
  - Ex. hardware: un stick USB (ex. YubiKey) pe care il introduci in PC si il atingi pentru a te loga.
  - Ex. software: aplicatia Google Authenticator, care genereaza un cod de 6 cifre.
Def. Autentificare cu cheie publica = metoda bazata pe criptografie asimetrica unde user-ul detine o cheie privata si serverul detine
     cheia publica corespunzatoare.
  - nu se transmit parole prin retea (dispare riscul unui atac Man-In-The-Middle)
  - Ex. SSH: Accesarea unui server Linux de la distanta fara parola, folosind fisierul id_rsa (cheia privata) 

## 5.4.1: Baza de date de parole

- sistemul de operare detine o baza de date cu perechi (username, parola)
- autentificarea e reusita daca username-ul si parola introduse se regasesc in aceeasi pereche in baza de date

Baza de date cu parole e modificata de actiunile de lucru cu utilizatori
  - in momentul adaugarii unui utilizator in sistem
    - se adauga o noua pereche de nume si parola bazei de date
  - in momentul stergerii unui utilizator
    - se sterge o intrare existenta
  - in momentul schimbarii unei parole 
    - se modifica o intrare existenta
- se poate intampla ca o defectiune de sistem sa permita unui user neprivilegiat sa aiba acces la baza de date cu parole
  -> de aceea parolele nu sunt in format citibil (plain text), ci sunt criptate
Obs. /etc/passwd = fisierul cu baza de date despre utilizatori.
  - acest fisier nu poate retine parola deoarece multe comenzi trebuie sa il acceseze pentru a afal UID-ul user-ului
  - daca ar fi asa, orice comenzi obisnuite ar putea gasi parola user-ului
Obs. /etc/shadow = fisierul care reprezinta baza de date pentru parole in Linux
  - poate fi accesat doar de catre utilizatori privilegiati
  - o intrare (linie de configurare) in fisierul /etc/shadow contine numele de utilizator, parola criptata si informatii legate de gestiunea parolei
  - datele sunt separate prin ":"
  - Ex. student:$6$VNq0Dxyc$[...].:17749:0:99999:7:::
    - student = nume de utilizator
    - $6$VNq0Dxyc$[...]. = parola criptata (Hash-ul)
      - $6$ indică algoritmul folosit (SHA-512)
      - VNq0Dxyc este "Salt-ul" (un șir aleator care previne spargerea parolei prin Rainbow Tables)
      - restul este hash-ul propriu-zis
    - 17749 = data ultimei schimbări a parolei (calculată în număr de zile scurse de la 1 ianuarie 1970)
    - 0 = Numărul minim de zile înainte ca parola să poată fi schimbată (0 înseamnă că o poți schimba oricând)
    - 99999 = numărul maxim de zile după care parola trebuie schimbată (practic, nu expiră niciodată)
    - 7 = perioada de avertizare (cu 7 zile înainte de expirare, utilizatorul primește un mesaj de avertizare)
    - : (Gol): Perioada de inactivitate (câte zile după expirare contul mai rămâne activ înainte de a fi blocat).
    - : (Gol): Data la care contul expiră definitiv (exprimată tot în zile de la 1.01.1970).
    - : (Gol): Un câmp rezervat pentru utilizări viitoare.
Obs. Dacă exista un semn de exclamare (!) sau un asterisc (*) în locul hash-ului (câmpul 2), 
     înseamnă că utilizatorul are contul blocat sau nu are nicio parolă setată, deci nu se poate loga.
Obs. Dacă hash-ul începe cu (!!), parola a expirat și contul a fost blocat automat de sistem.

Prefixe pentru algoritmi Hashing:
  $1$ = MD5 - vulnerabil la coliziuni 
  $2a$ SAU $2y$ = Blowfish / bcrypt - rezistent la atacuri brute-force prin GPU (Graphics Processing Unit - componenta hardware specializata pt. grafica)
  $5$ = SHA-256 - folosit ca alternativa rapida pentru SHA-512
  $6$ = SHA-512 - standardul actual (default in Ubuntu/Debian/RHEL(Red Hat Enterprise Linux))
  $y$ = yescrypt - cel mai modern (default în Fedora/Debian 12+); rezistent la atacuri cu circuite dedicate (ASIC)
  $2b$ = variantă de bcrypt (similară cu 2a/2y).
  $3$ = NT Hash (folosit de sisteme Windows vechi, extrem de rar în Linux).
  $md5$ = o variantă specifică de MD5 utilizată uneori în configurații Apache.
  $sha1$ = algoritmul SHA-1, rar folosit acum în /etc/shadow deoarece este considerat nesigur.
Def. Atacuri cu circuite dedicate (ASIC) = utilizarea unor cipuri hardware special proiectate (Application-Specific Integrated Circuit) 
     pentru o singură sarcină: calcularea hash-urilor cu viteză extremă. Atacul e de tip brute-force.
Def. Algoritmii "memory-hard" = algoritmi proiectați să necesite o cantitate mare de memorie RAM pentru a calcula un singur hash. 
     - scopul este să facă atacurile hardware (ASIC/GPU) foarte scumpe și lente
  - algoritmii "memory-hard" sunt proiectați special pentru a neutraliza avantajul atacurilor de tip ASIC

Exemple de algoritmi "memory-hard":
  Argon2: cel mai performant instrument de hashing de parole; este standardul modern "memory-hard";
  yescrypt: bazat pe scrypt; cel folosit acum în distribuțiile Linux noi (Debian 12, Fedora).

In Windows:
  - baza de date pentru parole se numeste Security Account Manager (SAM)
  - se gaseste in \%SystemRoot%\system32\config\SAM
  - accesul la SAM are loc prin intermediul Windows Registry si e asemanator cu /etc/shadow -> parolele sunt mentinute criptate

## 5.4.2: Gestiunea parolelor

- un utilizator isi poate gestiona propria parola
- un utilizator administrativ poate gestiona parolele tuturor utilizatorilor

Exista urmatoarele actiuni de gestionare a parolelor:
  - schimbarea parolei
  - stabilirea duratei de viata a unei parole
  - blocarea parolei
- in Linux, modul uzual de gestiune a parolei este prin linia de comanda, folosind utilitarul "passwd"

Exemplu:
  - pentru utilizatorul neprivilegiat
      student@uso:~$ passwd
      Changing password for student.
      (current) UNIX password:
      Enter new UNIX password:
      Retype new UNIX password:
      passwd: password updated successfully
  - pentru utilizatorul administrativ
      root@uso:~# passwd teacher
      Enter new UNIX password:
      Retype new UNIX password:
      passwd: password updated successfully
Obs. Utilizatorul privilegiat nu trebuie sa introduca parola actuala inainte sa o modifice, spre deosebire de utilizatorul neprivilegiat.

Bitul SUID (Set Owner User ID):
  Problema: Fișierul `/etc/shadow` este protejat prin permisiuni stricte (600), putând fi accesat și modificat exclusiv de utilizatorul `root`.
  Soluția (SUID): Activarea bitului special SUID pe executabilul `passwd` forțează procesul să ruleze cu privilegiile proprietarului fișierului (`root`), nu ale utilizatorului curent.
  Efectul: Utilizatorul obișnuit obține drepturi administrative temporare strict pentru acea comandă, permițând actualizarea hash-ului parolei în `/etc/shadow`.
- Configurarea Proprietății (Ownership)
  - `sudo chown root /cale/catre/fisier` - Comanda pentru stabilirea proprietarului.
  - `root` - Trebuie să fie proprietarul pentru ca SUID să ofere privilegii administrative.
  - `Importanță` - SUID împrumută identitatea proprietarului; dacă acesta nu este root, comanda nu va avea acces la /etc/shadow.
  - `Sintaxă completă` - `sudo chown root:root /usr/bin/passwd` (asigură și grupul proprietar).
- Activarea Bitului Special SUID (Set Owner User ID) se poate face prin doua metode
  - Metoda Simbolică
    - `sudo chmod u+s /cale/catre/fisier` - Adaugă bitul special proprietarului.
    - `u` (user) + `s` (setid).
  - Metoda Numerică (Octală)
    - `sudo chmod 4755 /cale/catre/fisier` - Activează SUID folosind masca numerică.
    - `4` - Reprezintă bitul SUID (valoare 4000).
    - `755` - Permisiunile standard de execuție (rwxr-xr-x).
- Verificarea Implementării
  - `ls -l /cale/catre/fisier` - Vizualizarea drepturilor de acces.
  - `Simbolul 's'` - Înlocuiește 'x'-ul de la proprietar (ex: -rwsr-xr-x).
  - `S mare (S)` - Indică o eroare: SUID este setat, dar fișierul NU are drept de execuție.
- Mecanismul de Funcționare (Cazul passwd)
  - `Problema` - /etc/shadow este protejat (permisiuni 600, doar root are acces).
  - `Acțiunea SUID` - Când student rulează passwd, procesul devine temporar root.
  - `Finalitate` - Procesul poate scrie în /etc/shadow, permițând schimbarea parolei fără acces sudo direct.
- Securitate și Riscuri
  - `Privilege Escalation` - Riscul ca un user normal să devină root prin exploatarea unui binar cu SUID.
  - `Interdicție` - Nu se pune SUID pe scripturi (.sh) sau editoare de text (vim, nano).
  - `Audit` - `find / -perm -4000` - Găsește toate fișierele cu SUID din sistem.

Observatii:
1) Comanda stat /usr/bin/passwd afișează permisiunile atât în format simbolic, cât și numeric (octal), fiind foarte utilă pentru a vedea cifra 4 de la SUID clar.
2) Dacă vrei să elimini bitul SUID, folosește comanda sudo chmod u-s /cale/catre/fisier.
3) În Linux, binarul ping are adesea bitul SUID setat pentru a putea deschide socket-uri "raw", operațiune permisă în mod normal doar utilizatorului root.

Manipularea bitului SUID:
  - Ștergerea Bitului SUID (Revocarea Privilegiilor)
    - Metoda Simbolică
      - `sudo chmod u-s /usr/bin/passwd` - Elimină ( - ) bitul special de pe proprietar.
      - `Utilizare` - Se folosește atunci când un binar nu mai trebuie să ruleze cu drepturi de root.
    - Metoda Numerică (Octală)
      - `sudo chmod 0755 /usr/bin/passwd` - Setează bitul special la 0 (dezactivat).
      - `0` - Prima cifră indică absența oricărui bit special (SUID, SGID sau Sticky).
  - Identificarea Fișierelor cu SUID în Sistem
    - `find /usr/bin -perm -4000` - Caută în folderul binarelor toate fișierele care au exact bitul SUID setat.
    - `-perm -4000` - Filtrul pentru masca numerică a SUID (4).
    - `find / -perm -u=s 2>/dev/null` - Caută în tot sistemul fișierele cu SUID (metoda simbolică) și ascunde erorile de permisiuni.
  - Diagnosticarea Erorilor de Configurare (S mare vs s mic)
    - `ls -l /cale/fisier` - Verificarea stării curente.
    - `Eroare (S)` - Dacă execuți `sudo chmod u+s fisier` pe un fișier care NU are drept de execuție (`x`), `ls` va afișa `S` (S mare).
    - `Corecție` - `sudo chmod u+x /cale/fisier` - Transformă `S` în `s` mic, făcând SUID-ul funcțional.
  - Manipularea concomitentă cu alte drepturi
    - `sudo chmod 4700 /cale/fisier` - Activează SUID și restricționează restul accesului (doar proprietarul root poate citi/scrie/executa).
    - `Sintaxă` - `rws------` (rezultatul comenzii de mai sus).

Bitul SGID (Set Group ID):
  Mecanismul de Funcționare (SGID pe Fișiere și Directoare)
    Problema: Într-un mediu de lucru colaborativ, când un utilizator creează un fișier într-un folder partajat, 
            acel fișier primește grupul primar al utilizatorului, împiedicând ceilalți membri ai grupului proiectului să îl modifice.
    Soluția (SGID): Activarea bitului SGID pe un director forțează toate fișierele noi create în interior să moștenească automat 
            grupul proprietar al directorului, nu grupul utilizatorului care le-a creat.
    Efectul: Membrii aceluiași grup pot lucra împreună în același folder fără a fi nevoie să schimbe manual grupul fiecărui fișier 
            nou (comanda `chgrp`) pentru a permite accesul colegilor.
- Configurarea Proprietății de Grup
  - `sudo chgrp echipa_proiect /folder_partajat` - Comanda pentru stabilirea grupului care va fi moștenit.
  - `Sens` - SGID are impact doar dacă grupul directorului este cel sub care vor să colaboreze utilizatorii.
- Activarea Bitului Special SGID (Set Group ID)
  - Metoda Simbolică
    - `sudo chmod g+s /folder_partajat` - Adaugă bitul special grupului (g).
    - `g` (group) + `s` (setid).
  - Metoda Numerică (Octală)
    - `sudo chmod 2775 /folder_partajat` - Activează SGID folosind masca numerică.
    - `2` - Reprezintă cifra pentru SGID (valoarea 2000).
    - `775` - Permisiuni rwxrwxr-x (oferă drept de scriere grupului).
- Verificarea Implementării
  - `ls -ld /folder_partajat` - Vizualizarea drepturilor directorului (folosim `-d` pentru a vedea folderul, nu conținutul).
  - `Simbolul 's'` - Apare în locul 'x'-ului de la grup (ex: `drwxrwsr-x`).
  - `S mare (S)` - Indică faptul că SGID este setat, dar grupul NU are drept de execuție pe acel folder.
- Ștergerea și Căutarea SGID
  - `sudo chmod g-s /folder_partajat` - Elimină bitul SGID (metoda simbolică).
  - `find / -perm -2000 2>/dev/null` - Caută toate fișierele/directoarele cu SGID setat în sistem.

Observatii:
1) Dacă la proba practică se cere "ca toate fișierele create într-un folder să aparțină grupului 'profesori'", soluția este întotdeauna chmod g+s.
2) Valoarea octală pentru SGID este 2, deci în format de 4 cifre, orice permisiune care începe cu 2 (ex. 2770) indică prezența SGID.
3) Spre deosebire de SUID, SGID este util și pe scripturi în anumite contexte de rețea, dar utilizarea sa principală rămâne pe directoare pentru colaborare.

- expirarea si blocarea parolelor pot fi utile pentru crearea de conturi temporare
- un user cu parola blocata poate folosi si alte moduri de autentificare la acel cont, cum ar fi SSH

Utilitarul usermod
  - comanda folosita pentru a modifica setările unui cont de utilizator deja existent în sistemul Linux.
Exemplu:
  student@uso:~$ sudo usermod --expiredate 1 teacher
  student@uso:~$ su - teacher
  Password:
  Your account has expired;
  please contact your system administrator
  su: Authentication failure
  student@uso:~$
Obs. Comanda configurează contul să expire la 1 ianuarie 1970 făcându-l, astfel, inutilizabil.
  - este un exemplu de blocare prin expirare, nu de blocare prin parola
Steaguri esențiale:
  - usermod -e, --expiredate YYYY-MM-DD` - Setează data de expirare a contului.
    - Ex: sudo usermod -e 2026-12-31 student`
  - usermod -L, --lock` - Blochează parola utilizatorului (pune un "!" în fața hash-ului în /etc/shadow).
    - Ex: sudo usermod -L teacher`
  - usermod -U, --unlock` - Deblochează parola utilizatorului.
    - Ex: sudo usermod -U teacher`
  - usermod -s, --shell` - Modifică shell-ul de login al utilizatorului.
    - Ex: sudo usermod -s /bin/bash student`
  - usermod -d, --home` - Modifică directorul home (adesea folosit cu `-m` pentru a muta conținutul vechi).
    - Ex: sudo usermod -d /home/new_home -m student`
Obs. Blocarea cu `-L` oprește doar autentificarea prin parolă; dacă utilizatorul are chei SSH setate, acesta se poate loga în continuare. 
Obs. Expirarea cu `-e` este singura care oprește orice formă de acces.

Utilitarul passwd
  - comanda folosita pentru a schimba parola unui cont de utilizator
  - e utilitar interactiv, necesita intrarea de la utilizator
  - dificil de folosit pentru automatizare
Steaguri esențiale:
    - passwd -l, --lock` - Blochează parola (similar cu usermod -L).
      - Ex: sudo passwd -l teacher`
    - passwd -u, --unlock` - Deblochează parola.
      - Ex: sudo passwd -u teacher`
    - passwd -d, --delete` - Șterge parola utilizatorului (contul devine fără parolă, periculos).
      - Ex: sudo passwd -d student`
    - passwd -e, --expire` - Forțează expirarea parolei (utilizatorul TREBUIE să o schimbe la următoarea logare).
      - Ex: sudo passwd -e student`
    - passwd -S, --status` - Afișează starea parolei (L = locked, P = usable, NP = no password).
      - Ex: passwd -S student`
Obs. Root poate schimba parola oricui fără să cunoască parola veche, în timp ce un user normal trebuie să o introducă pe cea curentă pentru a rula comanda.

Utilitarul chpasswd
  - comanda folosita pentru a actualiza parolele în masă (pentru mai mulți utilizatori simultan) prin citirea datelor de la intrarea standard (stdin).
Exemplu:
    student@uso:~$ echo "teacher:woof2PhaiNiphooS" | sudo chpasswd
    - am schimbat parola utilizatorului teacher in valoarea woof2PhaiNiphooS
    - chpasswd primeste la intrarea standard linii de forma username:password si le schimbă în mod neinteractiv, folosibil în scripturi
Steaguri esențiale:
    - chpasswd -e, --encrypted` - Indică faptul că parolele primite la intrare sunt deja criptate (hash-uri), nu text clar.
      - Ex: echo 'student:$6$salt$hash' | sudo chpasswd -e`
    - chpasswd -c, --crypt-method` - Specifică algoritmul de criptare dorit (ex: SHA512).
      - Ex: echo "user:pass" | sudo chpasswd -c SHA512`
Obs. Este utilitarul preferat pentru Scripting la proba practică (ex: "Creați 100 de utilizatori cu parola implicită 'SchimbaMa123'").

Folosirea parolelor poate fi problematica pentru ca:
  - folosim foarte multe parole si, în mod ideal, trebuie să fie diferite între ele
  - parolele pot fi slabe si usor de ghicit
  - parolele trebuie să fie schimbate periodic, altfel sansele de fi ghicite/decriptate cresc
  - folosim parolele de pe dispozitive multiple: desktop, laptop, dispozitiv mobil

Pentru gestiunea parolelor se recomanda:
  - Parolele să fie lungi (cel putin 10 caractere) si să contină caractere diferite
      - se poate apela la un generator de parole precum utilitarul pwgen
  - nu notati parolele în clar pe hârtii sau în fisiere de unde pot fi usor citite
  - folositi un utilitar de tipul password manager care să retină parolele si să minimizeze riscul expunerii lor la un atacator
      - in acelasi timp, să ajute să fie accesibile de pe dispozitive multiple

## 5.4.3: Autentificare centralizata


