# Capitolul 5: Utilizatori

- utilizatorii creeaza procese (aplicatii) care folosesc resursele sistemului (Ex. procesor, memorie, I/O etc.)
- utilizatorii transfera date in SAU din sistemul de calcul folosind sistemul de fisiere sau reteaua
- utilizatorii au acces la resursele sistemului de calcul printr-un cont de user care are niste permisiuni
- pe un sistem de operare modern pot exista mai multi utilizatori, ale caror procese ruleaza separat (izolat)
- un cont de utilizator e reprezentat de username

## 5.1: Utilizatori de sistem

- sunt folosite pentru a obtine acces la resursele gestionate de sistemul de operare
- conturile de utilizator permit obtinerea unui shell si rularea de comenzi care creează procese
- in momentul autentificării unui utilizator de sistem, acesta are acces complet la o partedin sistemul de fisiere 
    - acest sistem de fisiere se numeste directorul home al utilizatorului, reprezentand directorul personal al acestuia
    - Ex. /home/student pe Linux, C:\user\student pe Windows si /Users/student pe macOS

## 5.1.1 Permisiuni si privilegii

- din punct de vedere al conceptelor de securitate:
  - utilizatorul e un agent
  - resursele puse la dispozitie sunt obiecte
Def. Politica de securitate (security policy) a sistemului precizează permisiunile si dictează ce agenti au acces la ce obiecte.
- definitia politicii de securitate da nastere termenilor permisiune si privilegiu
Def. Permisiunile = informatii aferente obiectului care stabilesc ce agenti pot face tipuri de actiuni.
Def. Privilegiile = certificate aferente agentului care stabilesc ce actiuni poate acesta întreprinde.
- in sistemele de operare de uz general (Linux, Windows, macOS), exista utilizatori obisnuiti (neprivilegiati) si utilizatori privilegiati
Def. Utilizatorii neprivilegiati au acces complet la o parte din sistemul de fisiere (directorul home) si pot crea procese care folosesc aceste resurse.
Def. Utilizatorii privilegiati pot face actiuni care afectează starea globală a sistemului: 
  - Ex. instalare de pachete, adăugare si stergere de utilizatori, repornirea sistemului, configurarea datei sistemului, 
        schimbarea permisiunilor sistemului, configurarea retelei etc.
Def. Superuser = utilizator cu permisiuni depline.
  - pe Linux / Unix se numeste root
  - pe Windows se numeste Administrator

## 5.2: Utilizatorul administrativ (superuser)

## 5.2: Utilizatorul administrativ (superuser)

- utilizatorul administrativ, superuserul, detine controlul complet al sistemului
- toate operatiile privilegiate, inaccesibile unui utilizator obisnuit neprivilegiat, sunt permise acestuia
- un utilizator obisnuit va accesa acest cont special pentru a realiza o operatie privilegiata
    - accesul se face daca utilizatorul stie parola sau forma de autentificare a acestuia
- faptul ca superuserul are acces complet la sistem il face foarte periculos de folosit
- daca un atacator obtine acces neautorizat la contul de superuser, atunci sistemul este compromis
- daca rulam gresit o comanda privilegiata, aceasta poate afecta iremediabil sistemul
- Ex. rm -fr /: comanda este celebra pentru ca poate fi folosita pentru a sterge tot sistemul de fisiere
    - daca este folosita de contul de root, aceasta comanda sterge continutul sistemului de fisiere incepand de la radacina (/)
- recomandari de folosire pentru superuser:
    - sa fie folosit contul doar cand este absoluta nevoie, pentru operatii privilegiate
    - nu va autentificati ca superuser pe interfata grafica
    - sa fie o parola sau forma de autentificare cat mai greu de accesat in mod neautorizat
    - sa fie evitata folosirea superuser-ului cand exista forme alternative de executare de actiuni privilegiate
- sistemele de operare moderne ofera optiuni alternative:
    - In Linux/Unix: sudo, bitul setuid, capabilitati (prezentate in Sectiunea 5.2.3)
    - In Windows: User Account Control (UAC)
        - Def. User Account Control = tehnologie care ofera un prompt care trebuie confirmat ori de cate ori se doreste realizarea unei actiuni privilegiate

## 5.2.1: Utilizatorul administrativ in Linux (root)

- utilizatorul administrativ in Linux este numit root
- utilizatorul root are acces complet la resursele sistemului si poate face orice operatii
- accesarea contului de root este evidentiata in linia de comanda prin simbolul # (diez) la finalul promptului
- Ex. Listing 5.1:
    student@uso:~$ sudo su
    [sudo] password for student:
    root@uso:/home/student#
- in secventa de mai sus:
    - utilizatorul initial este student, iar promptul sau are simbolul $ (dolar)
    - dupa folosirea sudo su si introducerea parolei, se obtine un shell privilegiat cu simbolul #
- accesarea unui cont se poate face in doua moduri:
    - autentificarea in sistem (la login in linia de comanda sau interfata grafica)
    - schimbarea utilizatorului curent in linia de comanda prin folosirea comenzii su (substitute user)
- nu este recomandata autentificarea direct in sistem folosind contul de root
    - orice aplicatie lansata din acest cont va avea acces complet, devenind o posibila zona de atac
- este recomandat sa folositi comanda su pentru schimbarea temporara a utilizatorului si apoi revenirea cu exit
- Ex. Listing 5.2:
    student@uso:~$ su
    Password:
    root@uso:/home/student# apt install deluge
    root@uso:/home/student# exit
    student@uso:~$

## 5.2.2: Utilitarul su

- utilitarul su este folosit pentru schimbarea utilizatorului, nu neaparat in root
- daca su nu primeste niciun argument sau primeste root, va schimba utilizatorul in root
- la rularea comenzii se cere parola noului utilizator (utilizatorul destinatie)
- Ex. Listing 5.3:
    student@uso:~$ su teacher
    Password:
    teacher@uso:/home/student$ exit

- diferenta intre su si su - (sau su -l):
    - su [user]: schimba doar identitatea, dar pastreaza directorul curent si variabilele de mediu ale vechiului utilizator
    - su - [user]: schimba identitatea si incarca complet mediul de lucru al noului utilizator (Login Shell)
    - se observa in prompt: la su - locatia se schimba automat in directorul home al noului user (simbolul ~)

- diferenta intre comenzile de iesire exit si logout:
    - exit: este comanda universala care inchide orice shell curent si te intoarce la utilizatorul anterior
    - logout: functioneaza doar daca shell-ul curent este un Login Shell (creat prin su - sau su -l)
    - Ex. in Listing 5.3:
        - la linia 3 s-a folosit exit deoarece su simplu nu creeaza un login shell
        - la liniile 6 si 9 s-a folosit logout deoarece su -l a creat o sesiune de login completa

- utilitarul su permite rularea unei comenzi fara a deschide un shell prin optiunea -c
    - se ruleaza direct comanda primita ca argument si apoi se revine automat la shell-ul initial
    - Ex. Listing 5.3 (punctul 10):
        student@uso:~$ su -l teacher -c whoami
        Password:
        teacher
    - dupa afisarea rezultatului (teacher), sesiunea se inchide singura fara a mai fi nevoie de exit sau logout

## 5.2.3: Alternative la root in Linux

- root detine controlul intregului sistem
- sistemele de operare moderne ofera optiuni de granularizare a privilegiilor
    - Ex. bitul setuid, capabilitati si utilitarul sudo

Bitul setuid (set-user-id-on-execution):
    - bit asociat unui fisier executabil
    - cand se executa fisierul, procesul nou creat nu va apartine celui care l-a executat, ci va apartine celui care a creat fisierul (de obicei root)
    - Ex. student@uso:~$ ls -l /bin/ping
          2 -rwsr-xr-x 1 root root 64424 Mar 10 2017 /bin/ping
          3 student@uso:~$ ls -l /bin/su
          4 -rwsr-xr-x 1 root root 44664 Jan 25 2018 /bin/su
          5 student@uso:~$ ls -l /usr/bin/sudo
          6 -rwsr-xr-x 1 root root 149080 Jan 31 2020 /usr/bin/sudo
    - in permisiunile fisierelor se observa litera "s" (bitul setuid)
    Obs. Prezenta bitului setuid pe un executabil detinut de root (de exemplu passwd, su, sudo) -> acele comenzi pot fi rulate de orice utilizator pentru a crea procese privilegiate
    - dezavantajul este ca procesul nou creat ruleaza cu privilegii complete de root

Capabilitatile:
    - mecanism in Linux
    - concept de baza in sistemele de operare
        - presupune atasarea unui privilegiu unui agent (obiect)
    - Ex. Executabilul aferent utilitarului ping are atasata capabilitatea cap_net_raw.
        - aceasta capabilitate înseamna ca procesele create din executabilul ping vor avea privilegiul de a crea resurse privilegiate necesare utilitarului ping
    Obs. Spre deosebire de bitul setuid, capabilitatile sunt granulare. 
        - un proces are atasate doar capabilitatile de care are nevoie.
    Exemple:
        - cap_net_raw: permite folosirea de socketi speciali (numiti raw)
        - cap_net_admin: permite configurarea retelei
        - cap_fowner: permite configurare de permisiuni pe orice fisier
        - cap_kill: permite transmiterea de semnale pe orice fisiere
    Def. Suportul de capabilitati = o componenta avansata a sistemului de operare, care permite dezvoltatorilor de aplicatii configurarea de privilegii granulare.

## 5.2.3.1 Utilitarul sudo

- bitul setuid si capabilitatile nu permit usor atasarea de privilegii utilizatorilor, sau configurarea personalizata (custom) a actiunilor care pot fi executate de acel user.
- pentru asta, solutia pe Linux este utilitar sudo
Def. sudo = utilitar care permite rularea unor comenzi in numele altui utilizator (in general root)
    - are o configurare granulara
    - permite precizarea explicita a ce comenzi sa fie rulate
Obs. Spre deosebire de utilitarul su, sudo nu necesita parola noului utilizator, ci parola utilizatorului curent.
- cand rulam sudo il succedem cu comanda pe care vrem sa o rulam ca root
- sudo permite unui user sa ruleze comensi ca un alt user printr-o configuratie din sistemul de configurare /etc/sudousers
- permisiunile de sudo (adica posibilitatea de a rula comenzi ca root) trebuie acordate cu grija utilizatorilor
- pentru a preveni editarea eronata a fisierului /etc/sudousers, folosim editorul visudo
    - folosim comanda visudo ca root SAU comanda sudo visudo

## 5.2.3.1.1: sudo si redirectare

- consideram urmatoarea situatie: redirectionam rezultatul rularii unei comenzi intr-un fisier privilegiat
- daca dorim sa activam rutarea pe un sistem Linux, rulam, ca root, comanda:
    - student@uso:~$ echo 1 > /proc/sys/net/ipv4/ip_forward
    Def. Activarea rutarii = transformarea dispozitivului de calcul in ruter
        - activarea rutării permite sistemului să primească pachete pe o interfață de rețea și să le trimită mai departe către destinația lor finală prin altă interfață.
        rolul valorilor 1 si 0 in fisierele de configurare:
        - rolul valorilor 1 si 0 in fisierele de configurare:
        - cifra 1 (sau orice valoare diferita de 0) = Activat (On / True)
        - cifra 0 = Dezactivat (Off / False)
        - importanta acestui mecanism:
            - in Linux, configurarea kernel-ului se face prin scrierea acestor valori in fisiere virtuale (totul este un fisier)
            - modificarea valorii in /proc schimba comportamentul sistemului instantaneu, fara a necesita restartarea serviciilor sau a calculatorului
    - Problema redirectarii cu sudo:
        - Comanda: student@uso:~$ sudo echo 1 > /proc/sys/net/ipv4/ip_forward
        - Rezultat: eroare 
            - desi "echo 1" ruleaza ca root prin sudo, redirectionarea (operatorul >) este gestionata de shell
            - shell-ul utilizatorului "student" nu are privilegii sa deschida fisierul de sistem pentru scriere
            - redirectionarea are loc PENTRU comanda sudo, nu IN INTERIORUL ei

Utilitarul tee:
- Def. tee = utilitar care citeste de la intrarea standard (stdin) si scrie simultan la iesirea standard (stdout) SI intr-unul sau mai multe fisiere.
- Ex. student@uso:~$ echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
    - echo 1:
        - ruleaza ca utilizator normal (student)
        - trimite cifra 1 catre conducta (pipe)
    - | (Pipe):
        - transporta datele de la echo catre tee
        - ATENTIE: Pipe-ul nu are nevoie de permisiuni pe fisierul de destinatie, deci nu blocheaza comanda
    - sudo tee [cale_fisier]:
        - utilitarul tee este lansat cu privilegii de ROOT
        - primeste cifra 1 prin pipe
        - fiind root, tee are dreptul sa deschida fisierul privilegiat si sa scrie in el
        - rezolva problema de "Permission denied" a redirectionarii simple
            Optiunea critica: -a (append)
            - implicit, tee suprascrie continutul fisierului (ca operatorul >)
            - tee -a: adauga informatia la sfarsitul fisierului (ca operatorul >>)
            - Ex. student@uso:~$ echo "text nou" | sudo tee -a /etc/hosts

## 5.3: Operații cu utilizatori

- in OS, un utilizator e reprezentat de procesele si resursele acestuia
- la nivelul OS, un user e identificat de un numar, numit user identifier (UID), asa cum un proces e identificat printr-un process identifier (PID)
- procesele si fisierele unui utilizator au în atributele acestora câmpul UID
    - pentru procese, acest câmp ofera informatii despre ce operatii asupra resurselor sistemului de operare pot fi executate de proces
        => procese: UID -> posibile operatii asupra resurselor OS
    - câmpul UID al fisierelor identifica utilizatorul care le detine
        => fisiere: UID -> identifica userul proprietar
Obs. Comanda ps (process status) afiseaza UID proceselor.
    Steaguri pentru ps:
        - ps -l (long format)
        - ps -e (everything): listeaza toate procesele
        - ps -u (user format)
        - ps -a (all without session leaders)
        - ps -f (full-listing)
        - ps -x : procese care ruleaza in background fara terminal
    - nu listeaza procesele care s-au terminat, ci doar cele care inca ruleaza
    - este utilizată pentru a afișa informații despre procesele care rulează în sistem
    - ps -o (output): permite sccesarea unui format personalizat de afisare (în loc să afișeze coloanele implicite, ps va afișa doar coloanele specificate imediat după acest steag)
        - PPID (Parent Process ID): indică sistemului de operare cine este părintele procesului curent
    - Ex. student@uso:~$ ps -o pid,ppid,uid,user,cmd
          PID PPID UID USER CMD
          24104 24103 1000 student -bash
          24610 24104 1000 student ps -o pid,ppid,uid,user,cmd
        - "-bash" este interpretorul de comenzi. Faptul ca am pus "-" in fata indica un Login Shell
        Obs.  PPID-ul lui ps (24104) este exact PID-ul lui bash.
Obs. Comanda stat listeaza UID-ul unui fisier.
    - Ex. student@uso:~$ stat vm-actions-log.txt
          File: vm-actions-log.txt
          Size: 4827 Blocks: 16 IO Block: 4096 regular file
          Device: 801h/2049d Inode: 659107 Links: 1
          Access: (0644/-rw-r--r--) Uid: ( 1000/ student) Gid: ( 1000/ student)
          Access: 2020-08-08 16:32:44.086193999 +0300
          Modify: 2018-08-21 14:37:44.316527432 +0300
          Change: 2018-08-21 14:37:44.320529432 +0300
          Birth: -

## 5.3.1: Atribute ale utilizatorilor. Informatii despre utilizatori

- utilitarul id: afișează UID, GID și grupurile din care face parte utilizatorul
    - Ex. student@uso:~$ id student
    - output-ul va arăta: uid=1000(student) gid=1000(student) groups=1000(student),27(sudo)...
- cele mai importante doua atribute ale unui user sunt: userneme-ul si user identifier (UID)
- ierarhia numerotării UID:
    - UID 0: este rezervat întotdeauna pentru utilizatorul root
    - UID 1 - 999: rezervate pentru conturi de sistem (servicii)
    - UID 1000+: alocate utilizatorilor obișnuiți
- pe sistemele Unix, un user are asociat un login shell
Def. Login shell = programul rulat in momentul autentificarii user-ului pe sistem (apare sub forma unui shell in linia de comanda).
- utilizatorii sunt grupati -> gestiune mai flexibila a accesului la resurse
    - un user poate face parte din unul sau mai multe grupuri
    - un grup poate contine 0 sau mai multi utilizatori
    - un user poate apartine unui sau mai multor grupuri
    - group identifier (GID): identificatorul grupului principal al utilizatorului
- în Linux, există două utilitare pentru crearea conturilor: `useradd` și `adduser`
- diferența între cele două:
    - useradd: utilitar de nivel scăzut (low-level), nu este interactiv
        - acesta creează utilizatorul, dar NU creează automat directorul home sau parola decât dacă sunt specificați parametri suplimentari
    - adduser: script de nivel înalt (high-level), interactiv
        - este recomandat pentru utilizatori deoarece creează automat directorul home, copiază fișierele de bază și solicită parola
- Ex. student@uso:~$ sudo adduser teacher
- procesul de adăugare implică mai mulți pași automați:
    - se adaugă o linie în fișierul `/etc/passwd`
    - se adaugă o linie în fișierul `/etc/shadow`
    - se creează un grup primar cu același nume în `/etc/group`
    - se creează directorul home la calea `/home/nume_utilizator`
    - se copiază fișierele de configurare inițiale (șabloane) din `/etc/skel`



## 5.3.2: Obtinerea de informatii despre utilizatori

- informatii despre user: nume, UID, home director
- pot fi obtinute prin: interfatele grafice aferente unui OS, distributii, utilitare in command line

## 5.3.2.1: Obtinerea de informatii despre useri in Linux

- in Linux, info despre userisunt stocate in fisiere de configurare dedicate
- in scenarii de administrare mai complexe, aceste informatii sunt pastrate intr-o baza de date 
   Fisier                         Rol                                       Informatii
/etc/passwd             informatii utilizatori            username, UID, home directory, GID, login shell
/etc/shadow               parole utilizatori            username, parola criptata, informatii expirare parola
/etc/group                informatii grupuri                    nume grup, GID, utilizatori aferenti

Obs. /etc/passwd este lizibil pentru orice user din sistem.
Obs. /etc/shadow necesita acces root pentru a fi citit.

Utilitae pe care le putem folosi pentru a obtine informatii despre utilizatori:
1)  id
    Rol: info despre user
    Fisierele investigate: /etc/passwd, /etc/group
2)  groups
    Rol: grupurile utilizatorului curent
    Fisierele investigate: /etc/group
3)  users, w, who
    Rol: useri autentificati in sistem acum 
    Fisierele investigate: /var/run/utmp
4)  whoami
    Rol: numele userului curent
    Fisierele investigate: N/A
5)  finger, pinky
    Rol: informatii complete despre un utilizator
    Fisierele investigate: /etc/passwd, /etc/group

Obs. Exista utilizatori care au configurat ca shell de login /bin/false SAU /bin/nologin.
    - acesti utilizatori nu se pot autentifica în sistem si nu pot obtine un shell de login
Def. Utilizatorii de sistem = cei care pot avea procese dar nu pot obtine shell de login.
Def. Utilizatorii interactivi = cei care pot obtine shell si pot rula apoi comenzi.

## 5.3.3: Gestiunea utilizatorilor si a grupurilor

- consta in crearea, stergerea si modificarea user-ilor si a grupurilor
- poate fi facuta doar de un user privilegiat

Operatiile de gestiune a utilizatorilor sunt:
    - crearea unui user
        - un nou cont, identificat prin nume si UID
    - stergerea unui user
        - dupa ce un cont e sters, nu mai pot fi create procese cu acel cont
    - crearea unui grup
    - stergerea unui grup
    - adaugarea unui user la un grup
    - stergerea unui user dintr-un grup
    - schimbarea parolei unui user
    - modificarea atributelor unui user: username, login shell, home directory

## 5.3.3.1: Gestiunea utilizatorilor si grupurilor in Windows

- o facem cu interfata din panoul de control
- exista si utilitare in command line, folosind interfata netsh

## 5.3.3.2: Gestiunea utilizatorilor si grupurilor în Linux

- in Linux, exista interfete grafice pentru gestiunea utilizatorilor in functie de mediul desktop folosit
    - Ex. de medii desktop: GNOME, KDE, XFCE etc.

Utilitare specifice pentru gestiunea in command line:
1)  useradd
    Rol: adaugare utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
2)  userdel
    Rol: sterge utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
3)  usermod
    Rol: modificare utilizator
    Fisierele modificate: /etc/passwd, /etc/shadow, /etc/group
4)  groupadd
    Rol: adaugare grup
    Fisierele modificate: /etc/group
5)  groupdel
    Rol: stergere grup
    Fisierele modificate: /etc/group
6)  groupmod
    Rol: modificare grup
    Fisierele modificate: /etc/group
7)  chsh
    Rol: modificare shell
    Fisierele modificate: /etc/passwd
8)  chfn
    Rol: modificare informatii utilizator
    Fisierele modificate: /etc/passwd
9)  passwd
    Rol: schimbare parola
    Fisierele modificate: /etc/shadow

- pe distributiile bazate pe Debian (Debian, Ubuntu, Linux Mint etc.), exista un set de utilitare mai usor de folosit care înglobeaza comenzile de mai sus

Diferenta dintre Utilitare de baza si Utilitar Wrapper:
    - utilitarele de baza: mai rapide si native sistemului
        - acestea sunt: useradd, userdel, groupadd, groupdel
    - utilitarele wrapper: mai interactive (recomandate pentru utilizare manuala)
        - acestea sunt: adduser, deluser, addgroup, delgroup
        - pentru Debian: chsh (schimbare shell de login), chfn (schimbare informatii), passwd (schimbare parola)

- in Linux / Unix exista doua tipuri de grupuri: primare si secundare
- un user apartine unui singur grup primar, si oricator grupuri secundare
Obs. Un grup, care este grup primar al unui user, nu poate fi sters
    - intai trebuie sters userul, apoi grupul

Modificarea și ștergerea utilizatorilor:
- usermod: utilitar folosit pentru a schimba proprietățile unui cont
    - Ex. `sudo usermod -s /bin/zsh student` (schimbă shell-ul implicit în zsh)
    - Ex. `sudo usermod -L student` (blochează contul - Lock)
- deluser / userdel: utilitare pentru ștergerea conturilor
    - implicit, aceste comenzi șterg doar contul, nu și fișierele utilizatorului
    - pentru a șterge și directorul home, se folosește opțiunea `--remove-home`
    - Ex. student@uso:~$ `sudo deluser --remove-home teacher`

## 5.4: Autentificare. Gestiunea parolelor

Def. Autentificare = procedura prin care un utilizator doreste acces la sistemul de operare.
- presupune fornizarea unui username si unei parole
- autentificarea e valabila si pentru aplicatii
  - Ex. aplicatii web, jocuri, aplicatii de baza de date, conturi bancare etc. 
- moduri de autentificare: folosirea de informatii biometrice, dispozitiv de tip token de autentificare, autentificare cu cheie publica
Def. Dispozitiv de tip token de autentificare = dispozitiv hardware sau aplicatie software care genereaza un cod numeric temporar (OTP - One Time Password)
     sau trimite o confirmare criptografica pentru a dovedi identitatea user-ului.
  - Ex. hardware: un stick USB (ex. YubiKey) pe care il introduci in PC si il atingi pentru a te loga.
  - Ex. software: aplicatia Google Authenticator, care genereaza un cod de 6 cifre.
Def. Autentificare cu cheie publica = metoda bazata pe criptografie asimetrica unde user-ul detine o cheie privata si serverul detine
     cheia publica corespunzatoare.
  - nu se transmit parole prin retea (dispare riscul unui atac Man-In-The-Middle)
  - Ex. SSH: Accesarea unui server Linux de la distanta fara parola, folosind fisierul id_rsa (cheia privata) 

## 5.4.1: Baza de date de parole

- sistemul de operare detine o baza de date cu perechi (username, parola)
- autentificarea e reusita daca username-ul si parola introduse se regasesc in aceeasi pereche in baza de date

Baza de date cu parole e modificata de actiunile de lucru cu utilizatori
  - in momentul adaugarii unui utilizator in sistem
    - se adauga o noua pereche de nume si parola bazei de date
  - in momentul stergerii unui utilizator
    - se sterge o intrare existenta
  - in momentul schimbarii unei parole 
    - se modifica o intrare existenta
- se poate intampla ca o defectiune de sistem sa permita unui user neprivilegiat sa aiba acces la baza de date cu parole
  -> de aceea parolele nu sunt in format citibil (plain text), ci sunt criptate
Obs. /etc/passwd = fisierul cu baza de date despre utilizatori.
  - acest fisier nu poate retine parola deoarece multe comenzi trebuie sa il acceseze pentru a afal UID-ul user-ului
  - daca ar fi asa, orice comenzi obisnuite ar putea gasi parola user-ului
Obs. /etc/shadow = fisierul care reprezinta baza de date pentru parole in Linux
  - poate fi accesat doar de catre utilizatori privilegiati
  - o intrare (linie de configurare) in fisierul /etc/shadow contine numele de utilizator, parola criptata si informatii legate de gestiunea parolei
  - datele sunt separate prin ":"
  - Ex. student:$6$VNq0Dxyc$[...].:17749:0:99999:7:::
    - student = nume de utilizator
    - $6$VNq0Dxyc$[...]. = parola criptata (Hash-ul)
      - $6$ indică algoritmul folosit (SHA-512)
      - VNq0Dxyc este "Salt-ul" (un șir aleator care previne spargerea parolei prin Rainbow Tables)
      - restul este hash-ul propriu-zis
    - 17749 = data ultimei schimbări a parolei (calculată în număr de zile scurse de la 1 ianuarie 1970)
    - 0 = Numărul minim de zile înainte ca parola să poată fi schimbată (0 înseamnă că o poți schimba oricând)
    - 99999 = numărul maxim de zile după care parola trebuie schimbată (practic, nu expiră niciodată)
    - 7 = perioada de avertizare (cu 7 zile înainte de expirare, utilizatorul primește un mesaj de avertizare)
    - : (Gol): Perioada de inactivitate (câte zile după expirare contul mai rămâne activ înainte de a fi blocat).
    - : (Gol): Data la care contul expiră definitiv (exprimată tot în zile de la 1.01.1970).
    - : (Gol): Un câmp rezervat pentru utilizări viitoare.
Obs. Dacă exista un semn de exclamare (!) sau un asterisc (*) în locul hash-ului (câmpul 2), 
     înseamnă că utilizatorul are contul blocat sau nu are nicio parolă setată, deci nu se poate loga.
Obs. Dacă hash-ul începe cu (!!), parola a expirat și contul a fost blocat automat de sistem.

Prefixe pentru algoritmi Hashing:
  $1$ = MD5 - vulnerabil la coliziuni 
  $2a$ SAU $2y$ = Blowfish / bcrypt - rezistent la atacuri brute-force prin GPU (Graphics Processing Unit - componenta hardware specializata pt. grafica)
  $5$ = SHA-256 - folosit ca alternativa rapida pentru SHA-512
  $6$ = SHA-512 - standardul actual (default in Ubuntu/Debian/RHEL(Red Hat Enterprise Linux))
  $y$ = yescrypt - cel mai modern (default în Fedora/Debian 12+); rezistent la atacuri cu circuite dedicate (ASIC)
  $2b$ = variantă de bcrypt (similară cu 2a/2y).
  $3$ = NT Hash (folosit de sisteme Windows vechi, extrem de rar în Linux).
  $md5$ = o variantă specifică de MD5 utilizată uneori în configurații Apache.
  $sha1$ = algoritmul SHA-1, rar folosit acum în /etc/shadow deoarece este considerat nesigur.
Def. Atacuri cu circuite dedicate (ASIC) = utilizarea unor cipuri hardware special proiectate (Application-Specific Integrated Circuit) 
     pentru o singură sarcină: calcularea hash-urilor cu viteză extremă. Atacul e de tip brute-force.
Def. Algoritmii "memory-hard" = algoritmi proiectați să necesite o cantitate mare de memorie RAM pentru a calcula un singur hash. 
     - scopul este să facă atacurile hardware (ASIC/GPU) foarte scumpe și lente
  - algoritmii "memory-hard" sunt proiectați special pentru a neutraliza avantajul atacurilor de tip ASIC

Exemple de algoritmi "memory-hard":
  Argon2: cel mai performant instrument de hashing de parole; este standardul modern "memory-hard";
  yescrypt: bazat pe scrypt; cel folosit acum în distribuțiile Linux noi (Debian 12, Fedora).

In Windows:
  - baza de date pentru parole se numeste Security Account Manager (SAM)
  - se gaseste in \%SystemRoot%\system32\config\SAM
  - accesul la SAM are loc prin intermediul Windows Registry si e asemanator cu /etc/shadow -> parolele sunt mentinute criptate

## 5.4.2: Gestiunea parolelor

- un utilizator isi poate gestiona propria parola
- un utilizator administrativ poate gestiona parolele tuturor utilizatorilor

Exista urmatoarele actiuni de gestionare a parolelor:
  - schimbarea parolei
  - stabilirea duratei de viata a unei parole
  - blocarea parolei
- in Linux, modul uzual de gestiune a parolei este prin linia de comanda, folosind utilitarul "passwd"

Exemplu:
  - pentru utilizatorul neprivilegiat
      student@uso:~$ passwd
      Changing password for student.
      (current) UNIX password:
      Enter new UNIX password:
      Retype new UNIX password:
      passwd: password updated successfully
  - pentru utilizatorul administrativ
      root@uso:~# passwd teacher
      Enter new UNIX password:
      Retype new UNIX password:
      passwd: password updated successfully
Obs. Utilizatorul privilegiat nu trebuie sa introduca parola actuala inainte sa o modifice, spre deosebire de utilizatorul neprivilegiat.

Bitul SUID (Set Owner User ID):
  Problema: Fișierul `/etc/shadow` este protejat prin permisiuni stricte (600), putând fi accesat și modificat exclusiv de utilizatorul `root`.
  Soluția (SUID): Activarea bitului special SUID pe executabilul `passwd` forțează procesul să ruleze cu privilegiile proprietarului fișierului (`root`), nu ale utilizatorului curent.
  Efectul: Utilizatorul obișnuit obține drepturi administrative temporare strict pentru acea comandă, permițând actualizarea hash-ului parolei în `/etc/shadow`.
- Configurarea Proprietății (Ownership)
  - `sudo chown root /cale/catre/fisier` - Comanda pentru stabilirea proprietarului.
  - `root` - Trebuie să fie proprietarul pentru ca SUID să ofere privilegii administrative.
  - `Importanță` - SUID împrumută identitatea proprietarului; dacă acesta nu este root, comanda nu va avea acces la /etc/shadow.
  - `Sintaxă completă` - `sudo chown root:root /usr/bin/passwd` (asigură și grupul proprietar).
- Activarea Bitului Special SUID (Set Owner User ID) se poate face prin doua metode
  - Metoda Simbolică
    - `sudo chmod u+s /cale/catre/fisier` - Adaugă bitul special proprietarului.
    - `u` (user) + `s` (setid).
  - Metoda Numerică (Octală)
    - `sudo chmod 4755 /cale/catre/fisier` - Activează SUID folosind masca numerică.
    - `4` - Reprezintă bitul SUID (valoare 4000).
    - `755` - Permisiunile standard de execuție (rwxr-xr-x).
- Verificarea Implementării
  - `ls -l /cale/catre/fisier` - Vizualizarea drepturilor de acces.
  - `Simbolul 's'` - Înlocuiește 'x'-ul de la proprietar (ex: -rwsr-xr-x).
  - `S mare (S)` - Indică o eroare: SUID este setat, dar fișierul NU are drept de execuție.
- Mecanismul de Funcționare (Cazul passwd)
  - `Problema` - /etc/shadow este protejat (permisiuni 600, doar root are acces).
  - `Acțiunea SUID` - Când student rulează passwd, procesul devine temporar root.
  - `Finalitate` - Procesul poate scrie în /etc/shadow, permițând schimbarea parolei fără acces sudo direct.
- Securitate și Riscuri
  - `Privilege Escalation` - Riscul ca un user normal să devină root prin exploatarea unui binar cu SUID.
  - `Interdicție` - Nu se pune SUID pe scripturi (.sh) sau editoare de text (vim, nano).
  - `Audit` - `find / -perm -4000` - Găsește toate fișierele cu SUID din sistem.

Observatii:
1) Comanda stat /usr/bin/passwd afișează permisiunile atât în format simbolic, cât și numeric (octal), fiind foarte utilă pentru a vedea cifra 4 de la SUID clar.
2) Dacă vrei să elimini bitul SUID, folosește comanda sudo chmod u-s /cale/catre/fisier.
3) În Linux, binarul ping are adesea bitul SUID setat pentru a putea deschide socket-uri "raw", operațiune permisă în mod normal doar utilizatorului root.

Manipularea bitului SUID:
  - Ștergerea Bitului SUID (Revocarea Privilegiilor)
    - Metoda Simbolică
      - `sudo chmod u-s /usr/bin/passwd` - Elimină ( - ) bitul special de pe proprietar.
      - `Utilizare` - Se folosește atunci când un binar nu mai trebuie să ruleze cu drepturi de root.
    - Metoda Numerică (Octală)
      - `sudo chmod 0755 /usr/bin/passwd` - Setează bitul special la 0 (dezactivat).
      - `0` - Prima cifră indică absența oricărui bit special (SUID, SGID sau Sticky).
  - Identificarea Fișierelor cu SUID în Sistem
    - `find /usr/bin -perm -4000` - Caută în folderul binarelor toate fișierele care au exact bitul SUID setat.
    - `-perm -4000` - Filtrul pentru masca numerică a SUID (4).
    - `find / -perm -u=s 2>/dev/null` - Caută în tot sistemul fișierele cu SUID (metoda simbolică) și ascunde erorile de permisiuni.
  - Diagnosticarea Erorilor de Configurare (S mare vs s mic)
    - `ls -l /cale/fisier` - Verificarea stării curente.
    - `Eroare (S)` - Dacă execuți `sudo chmod u+s fisier` pe un fișier care NU are drept de execuție (`x`), `ls` va afișa `S` (S mare).
    - `Corecție` - `sudo chmod u+x /cale/fisier` - Transformă `S` în `s` mic, făcând SUID-ul funcțional.
  - Manipularea concomitentă cu alte drepturi
    - `sudo chmod 4700 /cale/fisier` - Activează SUID și restricționează restul accesului (doar proprietarul root poate citi/scrie/executa).
    - `Sintaxă` - `rws------` (rezultatul comenzii de mai sus).

Bitul SGID (Set Group ID):
  Mecanismul de Funcționare (SGID pe Fișiere și Directoare)
    Problema: Într-un mediu de lucru colaborativ, când un utilizator creează un fișier într-un folder partajat, 
            acel fișier primește grupul primar al utilizatorului, împiedicând ceilalți membri ai grupului proiectului să îl modifice.
    Soluția (SGID): Activarea bitului SGID pe un director forțează toate fișierele noi create în interior să moștenească automat 
            grupul proprietar al directorului, nu grupul utilizatorului care le-a creat.
    Efectul: Membrii aceluiași grup pot lucra împreună în același folder fără a fi nevoie să schimbe manual grupul fiecărui fișier 
            nou (comanda `chgrp`) pentru a permite accesul colegilor.
- Configurarea Proprietății de Grup
  - `sudo chgrp echipa_proiect /folder_partajat` - Comanda pentru stabilirea grupului care va fi moștenit.
  - `Sens` - SGID are impact doar dacă grupul directorului este cel sub care vor să colaboreze utilizatorii.
- Activarea Bitului Special SGID (Set Group ID)
  - Metoda Simbolică
    - `sudo chmod g+s /folder_partajat` - Adaugă bitul special grupului (g).
    - `g` (group) + `s` (setid).
  - Metoda Numerică (Octală)
    - `sudo chmod 2775 /folder_partajat` - Activează SGID folosind masca numerică.
    - `2` - Reprezintă cifra pentru SGID (valoarea 2000).
    - `775` - Permisiuni rwxrwxr-x (oferă drept de scriere grupului).
- Verificarea Implementării
  - `ls -ld /folder_partajat` - Vizualizarea drepturilor directorului (folosim `-d` pentru a vedea folderul, nu conținutul).
  - `Simbolul 's'` - Apare în locul 'x'-ului de la grup (ex: `drwxrwsr-x`).
  - `S mare (S)` - Indică faptul că SGID este setat, dar grupul NU are drept de execuție pe acel folder.
- Ștergerea și Căutarea SGID
  - `sudo chmod g-s /folder_partajat` - Elimină bitul SGID (metoda simbolică).
  - `find / -perm -2000 2>/dev/null` - Caută toate fișierele/directoarele cu SGID setat în sistem.

Observatii:
1) Dacă la proba practică se cere "ca toate fișierele create într-un folder să aparțină grupului 'profesori'", soluția este întotdeauna chmod g+s.
2) Valoarea octală pentru SGID este 2, deci în format de 4 cifre, orice permisiune care începe cu 2 (ex. 2770) indică prezența SGID.
3) Spre deosebire de SUID, SGID este util și pe scripturi în anumite contexte de rețea, dar utilizarea sa principală rămâne pe directoare pentru colaborare.

- expirarea si blocarea parolelor pot fi utile pentru crearea de conturi temporare
- un user cu parola blocata poate folosi si alte moduri de autentificare la acel cont, cum ar fi SSH

Utilitarul usermod
  - comanda folosita pentru a modifica setările unui cont de utilizator deja existent în sistemul Linux.
Exemplu:
  student@uso:~$ sudo usermod --expiredate 1 teacher
  student@uso:~$ su - teacher
  Password:
  Your account has expired;
  please contact your system administrator
  su: Authentication failure
  student@uso:~$
Obs. Comanda configurează contul să expire la 1 ianuarie 1970 făcându-l, astfel, inutilizabil.
  - este un exemplu de blocare prin expirare, nu de blocare prin parola
Steaguri esențiale:
  - usermod -e, --expiredate YYYY-MM-DD` - Setează data de expirare a contului.
    - Ex: sudo usermod -e 2026-12-31 student`
  - usermod -L, --lock` - Blochează parola utilizatorului (pune un "!" în fața hash-ului în /etc/shadow).
    - Ex: sudo usermod -L teacher`
  - usermod -U, --unlock` - Deblochează parola utilizatorului.
    - Ex: sudo usermod -U teacher`
  - usermod -s, --shell` - Modifică shell-ul de login al utilizatorului.
    - Ex: sudo usermod -s /bin/bash student`
  - usermod -d, --home` - Modifică directorul home (adesea folosit cu `-m` pentru a muta conținutul vechi).
    - Ex: sudo usermod -d /home/new_home -m student`
Obs. Blocarea cu `-L` oprește doar autentificarea prin parolă; dacă utilizatorul are chei SSH setate, acesta se poate loga în continuare. 
Obs. Expirarea cu `-e` este singura care oprește orice formă de acces.

Utilitarul passwd
  - comanda folosita pentru a schimba parola unui cont de utilizator
  - e utilitar interactiv, necesita intrarea de la utilizator
  - dificil de folosit pentru automatizare
Steaguri esențiale:
    - passwd -l, --lock` - Blochează parola (similar cu usermod -L).
      - Ex: sudo passwd -l teacher`
    - passwd -u, --unlock` - Deblochează parola.
      - Ex: sudo passwd -u teacher`
    - passwd -d, --delete` - Șterge parola utilizatorului (contul devine fără parolă, periculos).
      - Ex: sudo passwd -d student`
    - passwd -e, --expire` - Forțează expirarea parolei (utilizatorul TREBUIE să o schimbe la următoarea logare).
      - Ex: sudo passwd -e student`
    - passwd -S, --status` - Afișează starea parolei (L = locked, P = usable, NP = no password).
      - Ex: passwd -S student`
Obs. Root poate schimba parola oricui fără să cunoască parola veche, în timp ce un user normal trebuie să o introducă pe cea curentă pentru a rula comanda.

Utilitarul chpasswd
  - comanda folosita pentru a actualiza parolele în masă (pentru mai mulți utilizatori simultan) prin citirea datelor de la intrarea standard (stdin).
Exemplu:
    student@uso:~$ echo "teacher:woof2PhaiNiphooS" | sudo chpasswd
    - am schimbat parola utilizatorului teacher in valoarea woof2PhaiNiphooS
    - chpasswd primeste la intrarea standard linii de forma username:password si le schimbă în mod neinteractiv, folosibil în scripturi
Steaguri esențiale:
    - chpasswd -e, --encrypted` - Indică faptul că parolele primite la intrare sunt deja criptate (hash-uri), nu text clar.
      - Ex: echo 'student:$6$salt$hash' | sudo chpasswd -e`
    - chpasswd -c, --crypt-method` - Specifică algoritmul de criptare dorit (ex: SHA512).
      - Ex: echo "user:pass" | sudo chpasswd -c SHA512`
Obs. Este utilitarul preferat pentru Scripting la proba practică (ex: "Creați 100 de utilizatori cu parola implicită 'SchimbaMa123'").

Folosirea parolelor poate fi problematica pentru ca:
  - folosim foarte multe parole si, în mod ideal, trebuie să fie diferite între ele
  - parolele pot fi slabe si usor de ghicit
  - parolele trebuie să fie schimbate periodic, altfel sansele de fi ghicite/decriptate cresc
  - folosim parolele de pe dispozitive multiple: desktop, laptop, dispozitiv mobil

Pentru gestiunea parolelor se recomanda:
  - parolele să fie lungi (cel putin 10 caractere) si să contină caractere diferite
      - se poate apela la un generator de parole precum utilitarul pwgen
  - nu notati parolele în clar pe hârtii sau în fisiere de unde pot fi usor citite
  - folositi un utilitar de tipul password manager care să retină parolele si să minimizeze riscul expunerii lor la un atacator
      - in acelasi timp, să ajute să fie accesibile de pe dispozitive multiple

## 5.4.3: Autentificare centralizata

- este problematic pentru un utilizator sa aiba un cont si o parola pentru fiecare aplicatie folosita
- solutia: autentificarea centralizata
Def. Autentificarea centralizata = presupune existenta unui serviciu de autentificare care gestioneaza baza de date de parole
  - acest serviciu este accesat de diferite aplicatii
- autentificarea centralizata implica folosirea acelasi nume de utilizator si aceeasi parola pentru mai multe aplicatii
- aplicatiile trimit mai departe catre baza de date informatiile introduse de user; daca sunt corecte, utilizatorul primeste acces

Pentru Windows:
  - autentificarea centralizata se bazeaza pe serviciul AD (Active Directory)
Pentru Linux:
  - autentificarea centralizata se bazeaza pe serviciul LDAP (Lightweight Directory Access Protocol)

## 5.5: Accesul la sistemul de fisiere

- conturile de utilizator, in OS, au rolul de a separa resursele (Ex. Sistemul de fisiere) la care au acces fiecare utilizator
- fiecare user are un director Home la care are permisiuni complete
- un anumit agent (subiect) are un anumit acces la unele resurse (obiecte)
- spunem ca agentul este utilizatorul, iar resursa este fisierul
  - mai precis, agentul este un proces apartinand unui utilizator
Def. Un prroces este un program in executie:
Explicatie: Un program este o entitate pasiva (un fisier pe disc, ex. /bin/ls), iar procesul este entitatea activa care ocupa resurse
            si are un set de parmisiuni.

Procesul este definit de:
  - PID (Process ID): un numar unic de identificare 
  - Contextul de securitate (Credentiale): fiecare proces mosteneste identitatea user-ului care l-a lansat, avand un UID si GID
  - EUID / EGID (Effective UID/GID): sunt ID-urile "efective" pe care sistemul le verifică atunci când procesul cere acces la un fișier.
      - Exemplu: Când rulezi un fișier cu SUID root, procesul tău va avea UID-ul tău, dar EUID-ul va fi 0 (root).
  Obs. Este instanta vie a unui program, cea cu care interactioneaza userul.

Programul este definit de:
  - Definiție Statică
    - Un program este un fișier executabil stocat pe un mediu de stocare permanent (HDD/SSD).
    - Spre deosebire de proces, programul nu consumă timp de procesor (CPU) sau memorie RAM până când nu este lansat în execuție.
  - Cod Mașină (Instrucțiuni)
    - Reprezintă setul de instrucțiuni binare pe care procesorul trebuie să le execute.
    - Acestea sunt specifice arhitecturii sistemului (ex: x86_64 pentru PC-uri, ARM pentru telefoane).
  - Date Inițiale
    - Conține constante, mesaje text (ex: "Enter password:") și variabile predefinite de către programator.
    - Aceste date sunt încărcate în memorie în momentul în care programul devine proces.
  - Atribute de Sistem (Metadate)
    - `Proprietar (Owner)` - Utilizatorul care deține fișierul executabil (important pentru mecanismul SUID).
    - `Permisiuni` - Bitul de execuție (+x) care îi spune sistemului că fișierul poate fi lansat ca proces.
    - `Punct de intrare (Entry Point)` - Adresa primei instrucțiuni care trebuie executată din codul mașină.
  - Resurse Externe Necesare
    - `Biblioteci Partajate (Libraries)` - Referințe către alte fișiere (ex: .so în Linux, .dll în Windows) de care programul are nevoie pentru a funcționa.
  Obs. Este o entitate statica, pasiva, stocata pe disc.
  Obs. Un program poate genera mai multe procese (ex. Firecox poate fi deschis de mai multe ori).
  Obs. Un proces nu poate sa apartina mai multor programe.

## 5.5.1: Gestiunea permisiunilor in Windows

- in Windows, permisiunile sunt retinute in forma unor liste de acces (ACL - Access Control List)
Pentru un user, pot fi precizate mai multe tipuri de permisiuni:
  - List Folder/Read Data: utilizatorul poate lista continutul unui director si datele unui fisier
  - Create Files/Write Data: utilizatorul poate crea fisiere într-un director si poate scrie date într-un fisier
  - Traverse Folder/Execute File: utilizatorul poate traversa un director si poate executa un fisier

## 5.5.2: Gestiunea parmisiunilor in Linux

- fiecare fisier are metadate
Metadate relevante pentru permisiuni:
  - user: utilizatorul fisierului
  - group: grupul fisierului
  - permisiuni: informatii despre ce tipuri de accesari sunt permise si cui

Exista 3 tipuri de entitati pentru care se pot configura permisiuni:
  - user (utilizator): utilizatorul fisierului
  - group (grup): grupul fisierului
  - others (ceilalti): ceilalti utilizatori, diferiti de utilizatorul fisierului si care nu fac parte din grupul fisierului

Exista 3 tipuri de permisiuni:
  - read (citeste): fisierul poate fi citit, directorul poate fi listat
  - write (scrie): fisierul poate fi modificat, pot fi adăugate / sterse intrări în director
  - execute (executa): fisierul poate fi executat, directorul poate fi parcurs

- Algoritmul de Verificare a Permisiunilor (Ierarhia de acces)
  - Pasul 1: Identificarea Agentului
    - Sistemul determină cine este posesorul procesului (UID-ul procesului).
  - Pasul 2: Verificarea la nivel de User (Proprietar)
    - `Comparație`: Este UID-ul procesului == UID-ul proprietarului fișierului?
    - `Dacă Da`: Se aplică DOAR prima triadă de permisiuni (ex: `rwx------`). 
    - `Efect`: Dacă ai permisiune, treci. Dacă NU ai (chiar dacă grupul ar avea), ești blocat direct ("Permission denied").
  - Pasul 3: Verificarea la nivel de Group (Grup)
    - `Comparație`: Face utilizatorul parte din GID-ul fișierului?
    - `Dacă Da`: Se aplică a doua triadă de permisiuni (ex: `---r-x---`).
    - `Efect`: Dacă grupul are acces, treci. Dacă nu, mergi la pasul următor.
  - Pasul 4: Verificarea la nivel de Others (Alții)
    - `Acțiune`: Dacă nu ești nici proprietar, nici membru al grupului, se aplică ultima triadă (ex: `------r--`).
    - `Rezultat`: Dacă permisiunea există, treci. Dacă nu, accesul este respins definitiv.
Obs. Această verificare se face pe baza EUID (Effective UID) al procesului. Dacă procesul are SUID, 
     verificarea de la Pasul 1 se va face cu UID-ul proprietarului fișierului executabil (de obicei root).

Reguli de Acces: Director vs. Fișier
  - Traversarea (Calea)
    - `Cerință`: Permisiune de execuție (x) pe toate directoarele din cale.
    - `Exemplu`: Pentru `cd /home/student/proiect`, directoarele `home`, `student` și `proiect` trebuie să aibă bitul `x`.
  - Listarea (ls)
    - `Cerință`: Permisiune de citire (r) ȘI execuție (x) pe acel director.
    - `Obs`: Doar `r` pe director îți permite să vezi numele fișierelor, dar nu și detaliile lor (dimensiune, proprietar).
  - Citirea unui fișier (cat, less)
    - `Cerință`: r pe fișier + x pe directorul părinte.
    - `Comparație`: Dacă ai `r` pe fișier dar NU ai `x` pe folder, nu poți nici măcar să "ajungi" la fișier pentru a-l citi.
  - Editarea unui fișier (nano, vim)
    - `Cerință`: w pe fișier + x pe directorul părinte.
    - `Obs`: Nu ai nevoie de `r` pe fișier ca să scrii peste el (dar e greu să editezi fără să vezi ce e acolo).
  - Crearea/Ștergerea (rm, touch, mkdir)
    - `Cerință`: w ȘI x pe directorul părinte.
    - `CRITIC`: Nu contează ce permisiuni are fișierul în sine! Dacă ai `wx` pe folder, poți șterge un fișier chiar dacă acesta este deținut de root și are permisiuni `000`.
  - Execuția unui program (./script.sh)
    - `Cerință`: r ȘI x pe fișier + x pe directorul părinte.
    - `De ce r?`: Sistemul trebuie să poată citi instrucțiunile din fișier pentru a le încărca în RAM.

## 5.5.2.1: Formatul permisiunilor

Permisiunile sunt listate ca un sir de 9 caractere:
  - primele 3 sunt permisiuni pt user
  - urmatoarele 3 sunt pentru grup
  - ultimele 3 sunt permisiunu pentru others

Logica de Calcul (Sistemul 4-2-1):
  - Fiecare permisiune dintr-o triadă are o valoare fixă:
    - r (read) = 4 (binar 100)
    - w (write) = 2 (binar 010)
    - x (execute) = 1 (binar 001)
    - - (none) = 0 (binar 000)
  - `Metodă`: Aduni valorile active dintr-o triadă pentru a obține cifra corespunzătoare.

- Tabel de Corespondență Rapidă
  | Simbolic | Binar | Octal | Semnificație              |
  | :---     | :---  | :---  |         :---              |
  | `---`    | 000   | **0** | Nicio permisiune          |
  | `--x`    | 001   | **1** | Doar execuție             |
  | `-w-`    | 010   | **2** | Doar scriere              |
  | `-wx`    | 011   | **3** | Scriere și execuție (2+1) |
  | `r--`    | 100   | **4** | Doar citire               |
  | `r-x`    | 101   | **5** | Citire și execuție (4+1)  |
  | `rw-`    | 110   | **6** | Citire și scriere (4+2)   |
  | `rwx`    | 111   | **7** | Acces complet (4+2+1)     |

Structura celor 3 cifre
  - Cifra 1: User (Proprietar)
  - Cifra 2: Group (Grup)
  - Cifra 3: Others (Alții)
  - `Exemplu`: 755 -> Proprietarul face tot (7), Grupul și Alții doar citesc și traversează (5).

## 5.5.3: Comenzi pentru gestionarea permisiunilor

- pentru gestiunea permisiunilor:
    - comenzi de afisare a metadatelor fisierului (user, grup si permisiuni)
    - comenzi de modificare a metadatelor

1. Afisarea metadatelor:

Utilitarul ls (list) - Modul de afișare detaliată
- Comanda este folosită pentru a vedea cine deține fișierul și ce drepturi sunt active.

- Steaguri (Flag-uri) și Exemple:
  - -l (long format): Afișează coloanele de metadate (permisiuni, proprietar, grup, mărime, dată).
  - Comandă terminal: ls -l /etc/passwd
  - -d (directory): Vizualizează metadatele directorului în sine, nu conținutul său.
  - Comandă terminal: ls -ld /home/student
  - -n (numeric): Afișează UID și GID sub formă de numere în loc de nume.
  - Comandă terminal: ls -ln /etc/shadow
  - -h (human-readable): Afișează mărimea fișierelor în formate KB, MB, GB.
  - Comandă terminal: ls -lh /boot/vmlinuz
  - -i (inode): Afișează identificatorul unic (index node) al fișierului.
  - Comandă terminal: ls -li /etc/hosts
  - -a (all): Afișează și fișierele ascunse (cele care încep cu punct).
  - Comandă terminal: ls -la /home/student
  - -A (almost-all): Afișează fișierele ascunse, dar exclude directorul curent (.) și cel părinte (..).
  - Comandă terminal: ls -lA /home/student
  - -F (classify): Adaugă un indicator vizual numelui (ex: / pentru directoare, * pentru executabile).
  - Comandă terminal: ls -F /bin
  - -R (recursive): Afișează conținutul tuturor subdirectoarelor în mod ierarhic.
  - Comandă terminal: ls -lR /etc/network
  - -t (time): Sortează fișierele după timpul ultimei modificări (cele mai noi primele).
  - Comandă terminal: ls -lt /var/log
  - -r (reverse): Inversează ordinea sortării (utilizat des împreună cu -t).
  - Comandă terminal: ls -ltr /var/log
  - -S (size): Sortează fișierele după dimensiune (cele mai mari primele).
  - Comandă terminal: ls -lS /var/log

 Utilitarul stat
- Comanda oferă detalii profunde despre fișier, incluzând timpii de acces și permisiunile octale.

Steaguri (Flag-uri) și Exemple:
- -c (format): Permite extragerea unei anumite metadate (ex: %a pentru permisiuni octale, %U pentru nume proprietar).
- Comandă terminal: stat -c %a /etc/shadow
- -t (terse): Afișează informațiile într-un format compact, pe o singură linie.
- Comandă terminal: stat -t /etc/hostname
- -f (file system): Afișează starea sistemului de fișiere unde este stocat obiectul (blocuri, inode-uri libere).
- Comandă terminal: stat -f /
- -L (dereference): Dacă fișierul este un link simbolic, afișează metadatele fișierului către care punctează, nu ale linkului.
- Comandă terminal: stat -L /bin/sh

Comparație și Exemple:
- Poți vedea rapid care este cel mai mare fișier dintr-un folder?
- Răspuns: Da, folosind ls -lS.
- Poți vedea ultimele log-uri generate în ordine cronologică?
- Răspuns: Da, folosind ls -ltr (cele mai recente vor apărea la sfârșitul listei).
- Dacă un fișier este un link simbolic, ls -l îți arată unde punctează?
- Răspuns: Da, în ultima coloană vei vedea nume_link -> nume_tinta.

Obs. Combinația ls -alt este salvatoare când trebuie să găsești ce fișier a fost modificat de un atacator sau de un script într-un director cu mii de fișiere ascunse.

2. Modificarea metadatelor:
- primele doua comenzi (chown si chgrp) modifica utilizatorul si grupul
- chown poate modifica si utilizatorul si grupurile
- chgrp poate modifica doar grupuri
- chmod modifica permisiunile

Utilitarul chown (change owner)
- Comanda este folosită pentru a schimba utilizatorul proprietar și grupul unui fișier sau director. Poate fi rulată doar de utilizatorul privilegiat (root).

- Steaguri:
  - -R (recursive): Modifică proprietarul pentru toate fișierele și subdirectoarele din interior.
  - Comandă terminal: sudo chown -R student /home/student/proiect
  - -v (verbose): Afișează un mesaj de confirmare pentru fiecare fișier procesat.
  - Comandă terminal: sudo chown -v student invoice.pdf
  - -c (changes): Raportează doar fișierele unde s-a produs efectiv o schimbare de proprietar.
  - Comandă terminal: sudo chown -c teacher invoice.pdf
  - --reference: Copiază proprietarul de la un alt fișier model.
  - Comandă terminal: sudo chown --reference=model.txt invoice.pdf

Utilitarul chgrp (change group)
- Comanda este folosită exclusiv pentru a schimba grupul proprietar al unui fișier. Similar cu chown, necesită privilegii de root.

- Steaguri :
  - -R (recursive): Modifică grupul pentru un întreg arbore de directoare.
  - Comandă terminal: sudo chgrp -R staff /var/www
  - -v (verbose): Confirmă schimbarea grupului în terminal.
  - Comandă terminal: sudo chgrp -v avahi invoice.pdf
  - --reference: Aplică grupul de la un fișier sursă către fișierul destinație.
  - Comandă terminal: sudo chgrp --reference=config.log invoice.pdf

Utilitarul chmod (change mode)
- Comanda modifică permisiunile fișierelor. Poate fi rulată de root sau de proprietarul fișierului (owner).

- Steaguri:
  - -R (recursive): Aplică permisiunile în mod recursiv tuturor fișierelor dintr-un folder.
  - Comandă terminal: chmod -R 755 /home/student/public_html
  - -v (verbose): Afișează permisiunile setate pentru fiecare obiect.
  - Comandă terminal: chmod -v 644 road-trip.png
  - --reference: Setează permisiunile conform unui fișier de referință.
  - Comandă terminal: chmod --reference=script_vechi.sh script_nou.sh

Comparație și Exemple:
- Poate un utilizator obișnuit să schimbe proprietarul fișierului său către root?
- Răspuns: Nu. Doar superuser-ul poate folosi chown sau chgrp.
- Poate un utilizator să își blocheze singur accesul la un fișier propriu?
- Răspuns: Da, folosind chmod a-r nume_fisier. Totuși, fiind proprietar, poate reveni oricând asupra deciziei.
- Care este diferența de sintaxă la chown pentru a schimba și grupul simultan?
- Răspuns: Se folosește simbolul două puncte între utilizator și grup.
- Comandă terminal: sudo chown teacher:gdm invoice.pdf

Metode chmod:
- Vrei să setezi de la zero un set complet de permisiuni (ex: rw-r--r--)?
- Răspuns: Da, este preferată metoda octală.
- Comandă terminal: chmod 644 road-trip.png
- Vrei să faci o modificare mică fără să afectezi restul permisiunilor (ex: adăugare execuție)?
- Răspuns: Da, este preferată metoda simbolică.
- Comandă terminal: chmod g+x road-trip.png

Obs. Forma în octal a permisiunilor la chmod este preferată atunci când vrem să configurăm un nou set de permisiuni. 
     Când modificările sunt mici, forma simbolică (ex: g-w, o+w) este mai rapidă pentru actualizări punctuale.
Obs. Dacă vi se cere să permiteți grupului să scrie într-un fișier dar să eliminați dreptul de citire pentru ceilalți dintr-o singură comandă, 
     folosiți virgula în metoda simbolică: chmod g+w,o-r fisier.

## 5.5.3.1: Permisiuni de creare pentru fisiere

- se introduce comceptul umask (usermask)
- cand folosim comenzile touch (pt fisiere) si mkdir (pt directoare), le sunt asociate metadate implicite la creare
- stabilirea permisiunilor la creare tine de masca de creare a shell-ului (numita si "umask")
- masca de creare a shell-ului este o valoare pe biti folosita astfel: 
  - pt fisiere se face un SI logic intre valoarea 666 (octal) si maska inversata; 666 inseamna (rw-rw-rw-).
  - pt directoare se face un SI logic intre valoarea 777 (octal) si maska inversata; 777 inseamna (rwxrwxrwx).
Obs. Diferenta intre valorile octale atribuite apare pentru ca directoarele au nevoie de permisiuni de executie pentru toate operatiile, 
     iar fisierele nu au nevoie de aceste permisiuni (daca au nevoie, trebuie acordate explicit).

Tabel de corespondență umask:
| Mască de creare | Mască inversată | Permisiuni creare fișier (666 - Mască) | Permisiuni creare director (777 - Mască) |
| :---            | :---            | :---                                   | :---                                     |
| 022             | 755             | 644 (rw-r--r--)                        | 755 (rwxr-xr-x)                          |
| 002             | 775             | 664 (rw-rw-r--)                        | 775 (rwxrwxr-x)                          |
| 077             | 700             | 600 (rw-------)                        | 700 (rwx------)                          |

Utilitarul umask
- Comanda este folosită pentru afișarea sau setarea măștii de creare a shell-ului curent.

Steaguri:
- umask (fără parametru): Afișează masca curentă în format octal.
- Comandă terminal: umask
- -S (symbolic): Afișează masca în format simbolic (u=rwx,g=rx,o=rx), fiind mult mai ușor de citit.
- Comandă terminal: umask -S
- [valoare]: Modifică masca de creare pentru procesul curent de shell.
- Comandă terminal: umask 0022

Comparație și Exemple (Stilul Da/Nu):
- Dacă umask este 000, fișierele noi vor fi executabile?
- Răspuns: Nu. Chiar și cu umask 000, fișierele pornesc de la 666, deci vor avea cel mult 666 (rw-rw-rw-). Execuția se dă doar manual cu chmod.
- Este umask-ul o permisiune a fișierului?
- Răspuns: Nu. Este o setare a shell-ului (a procesului) care influențează doar fișierele create după momentul setării.
- Poți avea umask diferit pentru fișiere și directoare?
- Răspuns: Nu. Există o singură valoare umask, dar ea se aplică diferit (scăzută din 666 pentru fișiere și din 777 pentru directoare).

Obs. O metodă simplă de calcul la examen: Scade valoarea măștii din valoarea maximă (666 sau 777). 
Exemplu: Dacă umask este 027:
- Fișier: 666 - 027 = 640 (rw-r-----)
- Director: 777 - 027 = 750 (rwxr-x---)
Obs. Daca se cere să se afișeze permisiunile fișierului X folosind umask, întrebarea este o capcană. 
     Răspunsul corect este: Nu se poate, umask nu afișează permisiunile fișierelor existente.
Obs. Dacă vrei ca toate fișierele tale noi să fie private (doar tu să le vezi), rulează umask 0077. 
     Astfel, orice fișier creat ulterior va avea permisiunile 600.

## 5.5.4: Biti speciali de acces: setuid, setgid, sticky

- cand afisam masca de creare a shell-ului, observam ca sunt 4 cifre octale afisate (are structura pe 4 cifre)
- in mod normal, permisiunile au 3 cifre (user, group, others). 
- prima cifră (cea din stânga) reprezintă biții speciali, activați în această ordine: SUID (4), SGID (2), Sticky Bit (1).

1. Bitul setuid (SUID - Set User ID) - Valoare 4
- apare astfel: 4755 / -rwsr-xr-x
- Identificare: Apare litera s în locul x la proprietar.
- are sens cand este folosit pe fisiere executabile; adauga functionalitatea  de set user ID on execution
- Descriere: Procesul creat va rula cu drepturile proprietarului fișierului, nu ale celui care îl execută.
- Utilitate: Permite utilizatorilor obișnuiți să ruleze comenzi care au nevoie de privilegii de root (ex: schimbarea parolei).
- Comandă terminal (Activare octală): chmod 4755 nume_fisier
- Comandă terminal (Activare simbolică): chmod u+s nume_fisier

2. Bitul stegid (SGID - Set Group ID) - Valoare 2
- apare astfel: 2755 / drwxr-sr-x
- Identificare: Apare litera s în locul x la grup.
- Descriere: Pe fișiere, oferă drepturile grupului proprietar. 
             Pe directoare, forțează toate fișierele și subdirectoarele noi să moștenească grupul directorului părinte.
- Utilitate: Crearea de spații de lucru partajate pentru echipe (colaborare).
- Comandă terminal (Activare octală): chmod 2755 nume_director
- Comandă terminal (Activare simbolică): chmod g+s nume_director

3. Bitul sticky (Restricted Deletion) - Valoare 1
- apare astfel: 1777 / drwxrwxrwt
- Identificare: Apare litera t în locul x la others.
- Descriere: Previne ștergerea sau redenumirea fișierelor de către utilizatori care nu sunt proprietarii acelor fișiere, 
             chiar dacă au drept de scriere în director.
- Utilitate: Protejarea fișierelor în directoare publice (ex: /tmp).
- Comandă terminal (Activare octală): chmod 1777 nume_director
- Comandă terminal (Activare simbolică): chmod +t nume_director

Tabel de recapitulare (Cifra specială):
| Cifră | Bit activ    | Exemplu Octal  | Efect principal                          |
| :---  | :---         | :---           | :---                                     |
| 4     | SUID         | 4755           | Rulezi ca proprietarul (ex: root)        |
| 2     | SGID         | 2755           | Moștenire grup pe directoare             |
| 1     | Sticky       | 1777           | Doar proprietarul poate șterge fișierul  |
| 6     | SUID + SGID  | 6755           | Activare simultană 4 + 2                 |
| 7     | Toți biții   | 7777           | Activare 4 + 2 + 1                       |

Comparație și Exemple:
- Poate student să schimbe parola deși /etc/shadow este deținut de root?
- Răspuns: Da, deoarece /usr/bin/passwd are SUID (4755), deci procesul rulează ca root.
- Dacă creez un fișier într-un folder cu SGID, va aparține acesta grupului meu principal?
- Răspuns: Nu. Va aparține grupului setat pe directorul părinte.
- Într-un folder cu Sticky Bit activ (ca /tmp), pot șterge fișierul colegului dacă am amândoi permisiuni rwx?
- Răspuns: Nu. Sticky Bit te oprește dacă nu ești proprietarul fișierului sau root.

Obs. La examen, uitați-vă cu atenție la litera s sau t. Dacă este literă MARE (S sau T), înseamnă că bitul special este activat, dar bitul de execuție de dedesubt (x) lipsește, deci permisiunea specială ar putea să nu funcționeze corect.
     Comanda stat este cea mai sigură metodă de a vedea cifra specială (prima cifră din cele patru).
     Comandă terminal (Verificare rapidă): stat -c %a /usr/bin/passwd (va returna 4755).
